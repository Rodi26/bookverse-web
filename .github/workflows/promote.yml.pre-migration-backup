name: Promote


on:
  workflow_dispatch:
    inputs:
      target_stage:
        description: 'Target stage (DEV, QA, STAGING, PROD)'
        required: true
        type: choice                                                                      
        default: 'PROD'
        options: [ DEV, QA, STAGING, PROD ]
      application_version:
        description: 'Application version (SemVer) to promote (leave empty for latest)'
        required: false
        type: string
  workflow_call:
    inputs:
      target_stage:
        description: 'Target stage (DEV, QA, STAGING, PROD)'
        required: true
        type: string
      application_version:
        description: 'Application version (SemVer) to promote (leave empty for latest)'
        required: false
        type: string

jobs:
  promote:
    name: Promote
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    permissions:
      contents: read
      id-token: write
    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Setup] Prereqs (jq)"
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: "[Setup] JFrog CLI"
        # Temporary workaround: using forked action until upstream fix
        # uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
          JFROG_CLI_BUILD_NAME: ${{ github.event.repository.name }}_${{ github.workflow }}_${{ github.job }}
          JFROG_CLI_BUILD_NUMBER: ${{ github.run_number }}-${{ github.run_attempt }}
        with:
          version: latest
          oidc-provider-name: bookverse-web-github
          disable-job-summary: false
          oidc-audience: ${{ vars.JFROG_URL }}

      - name: "[Auth] Exchange OIDC and persist JF access token"
        id: exchange-oidc
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          PROJECT: ${{ vars.PROJECT_KEY }}
          PROVIDER_NAME: bookverse-web-github
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
          if [[ -z "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" || -z "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" ]]; then
            echo "âŒ Missing GitHub OIDC request env vars" >&2; exit 1; fi
          GH_ID_TOKEN=$(curl -sS -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" \
            "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${JF_URL}" | jq -r .value)
          if [[ -z "$GH_ID_TOKEN" || "$GH_ID_TOKEN" == "null" ]]; then echo "âŒ Failed to fetch GitHub ID token" >&2; exit 1; fi
          PAYLOAD=$(jq -n --arg jwt "$GH_ID_TOKEN" \
            --arg provider_name "$PROVIDER_NAME" \
            --arg project_key "$PROJECT" \
            --arg job_id "${{ github.job }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg repo "https://github.com/${{ github.repository }}" \
            --arg revision "${{ github.sha }}" \
            --arg branch "${{ github.ref_name }}" \
            '{
              grant_type:"urn:ietf:params:oauth:grant-type:token-exchange",
              subject_token_type:"urn:ietf:params:oauth:token-type:id_token",
              subject_token:$jwt,
              provider_name:$provider_name,
              project_key:$project_key,
              job_id:$job_id,
              run_id:$run_id,
              repo:$repo,
              revision:$revision,
              branch:$branch
            }')
          RESP=$(curl -sS -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "$JF_URL/access/api/v1/oidc/token")
          TOKEN=$(echo "$RESP" | jq -r '.access_token // empty')
          if [[ -z "$TOKEN" || "$TOKEN" == "null" ]]; then 
            echo "âŒ Failed to exchange OIDC token" >&2
            echo "Response: $RESP" >&2
            exit 1
          fi
          echo "JF_OIDC_TOKEN=$TOKEN" >> $GITHUB_ENV

      - name: "[Setup] Export env"
        run: |
          SERVICE_NAME=web
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          REGISTRY_URL="${{ vars.DOCKER_REGISTRY }}"
          DOCKER_REPO="${{ vars.PROJECT_KEY }}-${SERVICE_NAME}-internal-docker-nonprod-local"
          GENERIC_REPO="${{ vars.PROJECT_KEY }}-${SERVICE_NAME}-internal-generic-nonprod-local"
          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
          echo "APPLICATION_KEY=$APPLICATION_KEY" >> $GITHUB_ENV
          echo "REGISTRY_URL=$REGISTRY_URL" >> $GITHUB_ENV
          echo "DOCKER_REPO=$DOCKER_REPO" >> $GITHUB_ENV
          echo "GENERIC_REPO=$GENERIC_REPO" >> $GITHUB_ENV

      - name: "[Resolve] App & version"
        id: app
        run: |
          set -euo pipefail
          SERVICE_NAME=web
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          TARGET_STAGE='${{ inputs.target_stage }}'
          APP_VERSION='${{ inputs.application_version }}'
          if [ -z "$APP_VERSION" ]; then
            echo "ðŸ”Ž Fetching latest application version for $APPLICATION_KEY"
            BASE="${{ vars.JFROG_URL }}"; BASE="${BASE%/}"
            jq_expr='(.results // .data // .items // .versions)[0].version'
            RESP=$(curl -sS -H "Authorization: Bearer $JF_OIDC_TOKEN" -H "Accept: application/json" "$BASE/apptrust/api/v1/applications/$APPLICATION_KEY/versions?order_by=created&limit=1" || true)
            if LATEST_VERSION=$(echo "$RESP" | jq -er "$jq_expr" 2>/dev/null); then APP_VERSION="$LATEST_VERSION"; fi
            if [ -z "$APP_VERSION" ]; then
              echo "âŒ Could not determine latest application version for $APPLICATION_KEY" >&2
              echo "API Response: $RESP" >&2
              exit 1
            fi
          fi
          echo "application_key=$APPLICATION_KEY" >> $GITHUB_OUTPUT
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT
          echo "target_stage=$TARGET_STAGE" >> $GITHUB_OUTPUT
          echo "Resolved: $APPLICATION_KEY@$APP_VERSION â†’ $TARGET_STAGE"

      - name: "[Setup] AppTrust context"
        run: |
          set -euo pipefail
          export APPLICATION_KEY='${{ steps.app.outputs.application_key }}'
          export APP_VERSION='${{ steps.app.outputs.app_version }}'
          export TARGET_STAGE='${{ steps.app.outputs.target_stage }}'
          echo "APPLICATION_KEY=${{ steps.app.outputs.application_key }}" >> $GITHUB_ENV
          echo "APP_VERSION=${{ steps.app.outputs.app_version }}" >> $GITHUB_ENV
          echo "TARGET_STAGE=${{ steps.app.outputs.target_stage }}" >> $GITHUB_ENV
          export JFROG_URL="${{ vars.JFROG_URL }}"
          export PROJECT_KEY="${{ vars.PROJECT_KEY }}"
          # JF_OIDC_TOKEN is already set from OIDC exchange step above
          source .github/scripts/promote_lib.sh
          fetch_summary
          echo "CURRENT_STAGE_BEFORE=${CURRENT_STAGE:-UNASSIGNED}" >> $GITHUB_ENV
          echo "RELEASE_STATUS_BEFORE=${RELEASE_STATUS:-UNKNOWN}" >> $GITHUB_ENV
          LC_FILE=$(mktemp)
          CODE=$(curl -sS -L -o "$LC_FILE" -w "%{http_code}" "$JFROG_URL/access/api/v2/lifecycle/?project_key=$PROJECT_KEY" -H "Authorization: Bearer $JF_OIDC_TOKEN" -H "Accept: application/json" || echo 000)
          if [[ "$CODE" -lt 200 || "$CODE" -ge 300 ]]; then
            echo "âŒ Failed to fetch lifecycles list for project '$PROJECT_KEY' (HTTP $CODE)" >&2
            cat "$LC_FILE" || true
            rm -f "$LC_FILE"
            exit 1
          fi
          NORM_FILE=$(mktemp)
          jq -c 'if type=="array" then . elif has("lifecycles") then .lifecycles elif has("items") then .items elif has("results") then .results elif (has("name") and has("stages")) then [.] else [] end' "$LC_FILE" > "$NORM_FILE" 2>/dev/null || printf '[]' > "$NORM_FILE"
          rm -f "$LC_FILE"
          LIFECYCLE_NAME="${LIFECYCLE_NAME:-bookverse-lifecycle}"
          NAMES=$(jq -r --arg n "$LIFECYCLE_NAME" 'map(select(.name == $n)) | .[0].stages // [] | map(if type=="object" then .name else . end) | .[]' "$NORM_FILE" 2>/dev/null || true)
          RELEASE_STAGE=$(jq -r --arg n "$LIFECYCLE_NAME" '([ .[] | select(.name == $n) | .releaseStage ] | .[0]) // empty' "$NORM_FILE" 2>/dev/null || true)
          STAGES=(); while IFS= read -r orig; do [[ -z "$orig" ]] && continue; display=$(display_stage_for "$orig"); STAGES+=("$display"); done < <(printf "%s\n" "$NAMES")
          rm -f "$NORM_FILE"
          if [[ ${#STAGES[@]} -eq 0 ]]; then STAGES=(DEV QA STAGING PROD); fi
          if [[ -n "$RELEASE_STAGE" ]]; then FINAL_STAGE=$(display_stage_for "$RELEASE_STAGE"); else FINAL_STAGE="${STAGES[$((${#STAGES[@]}-1))]}"; fi
          echo "FINAL_STAGE=$FINAL_STAGE" >> $GITHUB_ENV
          STAGES_STR="${STAGES[*]}"; echo "STAGES_STR=$STAGES_STR" >> $GITHUB_ENV
          TARGET_NAME='${{ steps.app.outputs.target_stage }}'
          echo "TARGET_NAME=$TARGET_NAME" >> $GITHUB_ENV
          echo "PROMOTED_STAGES=" >> $GITHUB_ENV
          echo "DID_RELEASE=false" >> $GITHUB_ENV
          for s in ${STAGES_STR}; do
            if [[ "$s" != "PROD" ]]; then
              api=$(api_stage_for "$s")
              echo "STAGE_${s}_ORIG=$api" >> $GITHUB_ENV
            fi
          done
          echo "â„¹ï¸ Lifecycle stages: $STAGES_STR"
          echo "â„¹ï¸ Target: $TARGET_NAME; Final: $FINAL_STAGE"

      - name: "[Promote] UNASSIGNED â†’ next"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          export JFROG_URL='${{ vars.JFROG_URL }}'
          export PROJECT_KEY='${{ vars.PROJECT_KEY }}'
          # JF_OIDC_TOKEN already set by OIDC exchange
          source .github/scripts/promote_lib.sh
          fetch_summary
          ALLOW_RELEASE=false
          advance_one_step

      - name: "[Promote] Iterate to target (no release)"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          export JFROG_URL='${{ vars.JFROG_URL }}'
          export PROJECT_KEY='${{ vars.PROJECT_KEY }}'
          # JF_OIDC_TOKEN already set by OIDC exchange
          source .github/scripts/promote_lib.sh
          for i in 1 2 3 4; do
            fetch_summary
            PREV=$(display_stage_for "${CURRENT_STAGE:-UNASSIGNED}")
            echo "âž¡ï¸ Iteration $i begin: stage=$PREV target=$TARGET_NAME final=$FINAL_STAGE stages=[$STAGES_STR]"
            if [[ "$PREV" == "$TARGET_NAME" ]]; then
              echo "Reached target stage ($TARGET_NAME); stopping."
              break
            fi
            ALLOW_RELEASE=false
            advance_one_step
            fetch_summary
            CURR=$(display_stage_for "${CURRENT_STAGE:-UNASSIGNED}")
            echo "âž¡ï¸ Iteration $i result: $PREV -> $CURR"
            if [[ "$CURR" == "$PREV" ]]; then
              echo "No further non-release promotions possible; stopping."
              break
            fi
          done

      - name: "[Release] PROD"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
          EVIDENCE_KEY_ALIAS: ${{ vars.EVIDENCE_KEY_ALIAS }}
        run: |
          set -euo pipefail
          export JFROG_URL="${{ vars.JFROG_URL }}"
          export PROJECT_KEY="${{ vars.PROJECT_KEY }}"
          # JF_OIDC_TOKEN already set by OIDC exchange
          source .github/scripts/promote_lib.sh
          fetch_summary
          if [[ "$(display_stage_for "${CURRENT_STAGE:-}")" == "STAGING" ]]; then
            ALLOW_RELEASE=true
            advance_one_step
          else
            echo "Skipping release: current stage is $(display_stage_for "${CURRENT_STAGE:-UNASSIGNED}")"
          fi

      - name: "[Tags] Enforce PROD 'latest' invariants"
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
          APP_KEY="$APPLICATION_KEY"
          BASE="${{ vars.JFROG_URL }}/apptrust/api/v1"
          TOKEN="$JF_OIDC_TOKEN"
          RESP=$(mktemp)
          code=$(curl -sS -L -o "$RESP" -w "%{http_code}" \
            "$BASE/applications/$APP_KEY/versions?limit=1000&order_by=created&order_asc=false" \
            -H "Authorization: Bearer $TOKEN" -H "Accept: application/json" || echo 000)
          if [[ "$code" -lt 200 || "$code" -ge 300 ]]; then
            echo "âŒ Failed to list versions (HTTP $code)" >&2; cat "$RESP" || true; exit 1
          fi
          DESIRED=$(jq -r '[.versions[] | select((.release_status|tostring|ascii_upcase)=="RELEASED" or (.release_status|tostring|ascii_upcase)=="TRUSTED_RELEASE") | .version] | unique | map(select(test("^[0-9]+\\.[0-9]+\\.[0-9]+$"))) | sort_by(split(".")|map(tonumber)) | last // empty' "$RESP")
          if [[ -z "$DESIRED" ]]; then
            mapfile -t PREV_LATEST < <(jq -r '.versions[] | select(.tag=="latest") | .version' "$RESP")
            for pv in "${PREV_LATEST[@]:-}"; do
              [ -z "$pv" ] && continue
              restore=$(jq -r --arg v "$pv" '.versions[] | select(.version==$v) | (.properties.original_tag_before_latest[0] // .version // "")' "$RESP")
              printf '{"tag":"%s","delete_properties":["original_tag_before_latest"]}' "$restore" > body.json
              curl -sS -L -X PATCH "$BASE/applications/$APP_KEY/versions/$pv" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d @body.json | cat
            done
            rm -f "$RESP" body.json
            exit 0
          fi
          CURR_TAG=$(jq -r --arg v "$DESIRED" '.versions[] | select(.version==$v) | (.tag // "")' "$RESP")
          jq -n --arg ct "$CURR_TAG" '{tag:"latest", properties:{original_tag_before_latest:[$ct]}}' > body.json
          curl -sS -L -X PATCH "$BASE/applications/$APP_KEY/versions/$DESIRED" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d @body.json | cat
          mapfile -t OTHERS < <(jq -r --arg v "$DESIRED" '.versions[] | select(.tag=="latest" and .version!=$v) | .version' "$RESP")
          for ov in "${OTHERS[@]:-}"; do
            [ -z "$ov" ] && continue
            restore=$(jq -r --arg v "$ov" '.versions[] | select(.version==$v) | (.properties.original_tag_before_latest[0] // .version // "")' "$RESP")
            printf '{"tag":"%s","delete_properties":["original_tag_before_latest"]}' "$restore" > body.json
            curl -sS -L -X PATCH "$BASE/applications/$APP_KEY/versions/$ov" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d @body.json | cat
          done
          rm -f "$RESP" body.json || true

      - name: "[Evidence] Attach promotion"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          NOW_TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          TARGET_NAME_VAL="${TARGET_NAME:-${{ inputs.target_stage }}}"
          cat > promotion-evidence.json <<JSON
          {
            "promotion": {
              "to": "${TARGET_NAME_VAL}",
              "version": "${APP_VERSION}",
              "actor": "${{ github.actor }}",
              "timestamp": "${NOW_TS}"
            }
          }
          JSON
          cat > promotion-evidence.md <<EOF
          # Promotion Evidence

          - Application: \`$APPLICATION_KEY\`
          - Version: \`$APP_VERSION\`
          - Target: \`${TARGET_NAME_VAL}\`
          - Actor: \`${{ github.actor }}\`
          - Timestamp (UTC): \`${NOW_TS}\`
          EOF
          jf evd create-evidence \
            --predicate promotion-evidence.json \
            --markdown promotion-evidence.md \
            --predicate-type "https://jfrog.com/evidence/promotion/v1" \
            --release-bundle "$APPLICATION_KEY" \
            --release-bundle-version "$APP_VERSION" \
            --project "${{ vars.PROJECT_KEY }}" \
            --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" \
            --key-alias "${{ vars.EVIDENCE_KEY_ALIAS }}" || echo "âš ï¸ Promotion evidence attach failed"

      - name: "[Summary] Promotion"
        if: always()
        run: |
          set -euo pipefail
          CURRENT_DISPLAY="${CURRENT_STAGE_BEFORE:-UNASSIGNED}"
          CURRENT_DISPLAY="${CURRENT_DISPLAY#bookverse-}"
          TARGET_DISPLAY="${TARGET_NAME:-${FINAL_STAGE:-UNKNOWN}}"
          export CURRENT_DISPLAY TARGET_DISPLAY
          STAGES="${STAGES_STR:-DEV QA STAGING PROD}"
          IFS=' ' read -r -a STAGE_ARR <<< "$STAGES"
          idx_current=-1; idx_target=-1
          for i in "${!STAGE_ARR[@]}"; do
            if [[ "${STAGE_ARR[$i]}" == "$CURRENT_DISPLAY" ]]; then idx_current=$i; fi
            if [[ "${STAGE_ARR[$i]}" == "$TARGET_DISPLAY" ]]; then idx_target=$i; fi
          done
          pre=""; post=""; sep=""
          if [[ $idx_current -ge 0 && $idx_target -ge 0 ]]; then
            for ((j=0;j<idx_current;j++)); do
              if [[ -n "$pre" ]]; then sep=" â†’ "; else sep=""; fi
              pre+="$sep${STAGE_ARR[$j]}"
            done
            for ((j=idx_target+1;j<${#STAGE_ARR[@]};j++)); do
              if [[ -n "$post" ]]; then sep=" â†’ "; else sep=""; fi
              post+="$sep${STAGE_ARR[$j]}"
            done
            LC_PATH="${pre:+$pre â†’ }**${CURRENT_DISPLAY} âž” ${TARGET_DISPLAY}**${post:+ â†’ $post}"
          else
            LC_PATH="$STAGES"
          fi
          OUTCOME="SUCCESS"
          for s in "${PROMO_UNASSIGNED_STATUS:-}" "${PROMO_DEV_STATUS:-}" "${PROMO_QA_STATUS:-}" "${PROMO_STAGING_STATUS:-}" "${PROMO_RELEASE_STATUS:-}"; do
            if [[ "$s" == "FAILED" ]]; then OUTCOME="FAILURE"; fi
          done
          if [[ "$OUTCOME" == "SUCCESS" ]]; then
            for s in "${IAC_EVIDENCE_STATUS:-}" "${PENTEST_EVIDENCE_STATUS:-}" "${CHANGEAPPROVAL_EVIDENCE_STATUS:-}"; do
              if [[ "$s" == "FAILED" ]]; then OUTCOME="WARNING"; fi
            done
          fi
          PROMOTION_METHOD="move"
          node - <<'NODE' | tee -a "$GITHUB_STEP_SUMMARY" >/dev/null
          (function(){
            function iconFor(status){
              switch ((status||'').toUpperCase()) {
                case 'SUCCESS': return 'âœ…';
                case 'WARNING': return 'âš ï¸';
                case 'FAILURE': return 'âŒ';
                case 'FAILED': return 'âŒ';
                default: return 'â€“';
              }
            }
            const env = process.env;
            const app = env.APPLICATION_KEY || '';
            const ver = env.APP_VERSION || '';
            const current = env.CURRENT_DISPLAY || '';
            const target = env.TARGET_DISPLAY || '';
            const lifecycleDefined = `UNASSIGNED â†’ ${(env.STAGES_STR || 'DEV QA STAGING PROD').split(' ').join(' â†’ ')}`;
            const promoMethod = (env.PROMOTION_METHOD || 'move');
            const sUnassigned = (env.PROMO_UNASSIGNED_STATUS || '').toUpperCase();
            const sDev = (env.PROMO_DEV_STATUS || '').toUpperCase();
            const sQa = (env.PROMO_QA_STATUS || '').toUpperCase();
            const sStg = (env.PROMO_STAGING_STATUS || '').toUpperCase();
            const sRel = (env.PROMO_RELEASE_STATUS || '').toUpperCase();
            const evIac = (env.IAC_EVIDENCE_STATUS || '').toUpperCase();
            const evPentest = (env.PENTEST_EVIDENCE_STATUS || '').toUpperCase();
            const evChange = (env.CHANGEAPPROVAL_EVIDENCE_STATUS || '').toUpperCase();
            function stepOutcomeFromPlatform(stepStatus){
              const st = (stepStatus||'').toUpperCase();
              if (st === 'FAILED' || st === 'FAILURE') return 'FAILURE';
              if (!st) return 'SKIPPED';
              return 'SUCCESS';
            }
            function evidenceLine(name, status, hint){
              const up = (status||'').toUpperCase();
              if (up === 'FAILED') return `  - âŒ ${name} (failed)`;
              if (up === 'SUCCESS') return `  - âœ… ${name}`;
              return `  - ${name} (${hint || 'not evaluated'})`;
            }
            function stepSection(from, to, kind, constraints, evidences, stepStatus){
              const promoResult = stepOutcomeFromPlatform(stepStatus);
              const hasEvidenceFail = evidences.some(e => (e.status||'').toUpperCase() === 'FAILED');
              const stepOutcome = promoResult === 'FAILURE' ? 'FAILURE' : (hasEvidenceFail ? 'WARNING' : 'SUCCESS');
              const lines = [];
              lines.push(`### Step: ${from} â†’ ${to}`);
              lines.push(`- **Type:** ${kind}`);
              lines.push(`- **Constraints:** ${constraints || 'None'}`);
              lines.push(`- **Evidence Used:**`);
              if (!evidences.length) { lines.push(`  - (none)`); } else { evidences.forEach(e => lines.push(evidenceLine(e.name, e.status, e.hint))); }
              lines.push(`- **Promotion Result:** ${iconFor(promoResult)} ${promoResult}`);
              lines.push(`- **Step Outcome:** ${iconFor(stepOutcome)} ${stepOutcome}`);
              return { text: lines.join('\n'), outcome: stepOutcome };
            }
            const sec1 = stepSection('UNASSIGNED','DEV',`Promote (${promoMethod})`, 'None', [
              { name: 'SLSA Provenance (UNASSIGNED)', status: '', hint: 'attached in CI; not evaluated here' },
              { name: 'Jira Release Notes (UNASSIGNED)', status: '', hint: 'attached in CI; not evaluated here' },
            ], sUnassigned);
            const sec2 = stepSection('DEV','QA',`Promote (${promoMethod})`, 'None', [
              { name: 'Coverage (pytest) [Package]', status: '', hint: 'attached in CI; not evaluated here' },
              { name: 'SAST (Checkmarx) [Package]', status: '', hint: 'attached in CI; not evaluated here' },
            ], sDev);
            const sec3 = stepSection('QA','STAGING',`Promote (${promoMethod})`, 'None', [
              { name: 'DAST (Invicti)', status: '', hint: 'not configured in this workflow' },
              { name: 'API Tests (Postman)', status: '', hint: 'not configured in this workflow' },
            ], sQa);
            const sec4 = stepSection('STAGING','PROD',`Release (${promoMethod})`, 'None', [
              { name: 'Snyk IaC', status: evIac },
              { name: 'Cobalt Pentest', status: evPentest },
              { name: 'ServiceNow Change Approval', status: evChange },
            ], sRel);
            const outcomes = [sec1.outcome, sec2.outcome, sec3.outcome, sec4.outcome].filter(Boolean);
            let overall = 'SUCCESS';
            if (outcomes.some(o => o === 'FAILURE')) overall = 'FAILURE';
            else if (outcomes.some(o => o === 'WARNING')) overall = 'WARNING';
            const exec = [
              `### Executive Summary`,
              `- **Lifecycle:** ${lifecycleDefined}`,
              `- **Application:** ${app}`,
              `- **Version:** ${ver}`,
              `- **From â†’ To:** ${current} â†’ ${target}`,
              `- **Outcome:** ${iconFor(overall)} ${overall}`,
            ].join('\n');
            const report = [exec, '', sec1.text, '', sec2.text, '', sec3.text, '', sec4.text].join('\n');
            process.stdout.write(report);
          })();
          NODE

