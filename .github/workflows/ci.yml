# =============================================================================
# BookVerse Web UI Service - Comprehensive CI/CD Workflow
# =============================================================================
#
# This GitHub Actions workflow provides complete CI/CD automation for the BookVerse
# Web UI Service, implementing enterprise-grade frontend build processes, asset
# optimization, and performance-focused artifact management for the customer-facing
# web application that provides the complete BookVerse user experience.
#
# üèóÔ∏è WORKFLOW ARCHITECTURE:
#     - Modern Frontend Build: Vite-powered development and production builds
#     - Asset Optimization: JavaScript bundling, CSS minification, and image compression
#     - Performance Testing: Core Web Vitals validation and performance benchmarking
#     - Evidence Collection: Cryptographic signing and comprehensive frontend audit trails
#     - AppTrust Integration: Automated lifecycle management with frontend security validation
#     - CDN Deployment: Optimized content delivery and global distribution preparation
#
# üöÄ KEY FEATURES:
#     - Enterprise-grade frontend development with modern tooling and optimization
#     - Comprehensive performance testing framework for user experience validation
#     - Advanced asset bundling with tree-shaking and code splitting optimization
#     - Automated accessibility testing and compliance validation (WCAG 2.1 AA)
#     - Progressive Web App capabilities with service worker and offline support
#     - Zero-downtime deployment with blue-green frontend asset distribution
#
# üìä BUSINESS LOGIC:
#     - Customer Experience: Primary interface for all BookVerse customer interactions
#     - Revenue Enablement: Frontend foundation supporting all sales and conversion flows
#     - Brand Representation: Official BookVerse brand experience and visual identity
#     - Performance Excellence: Sub-2s page load times and 95+ Lighthouse scores
#     - Accessibility Compliance: Universal access meeting international standards
#     - SEO Optimization: Search engine visibility and organic traffic generation
#
# üõ†Ô∏è USAGE PATTERNS:
#     - Customer Shopping: Product browsing, search, and discovery experiences
#     - Purchase Flow: Complete checkout integration with payment processing
#     - User Account: Profile management, order history, and preference settings
#     - Content Delivery: Marketing pages, help content, and promotional materials
#     - Mobile Experience: Responsive design and progressive web app functionality
#
# ‚ö° TRIGGER CONDITIONS:
#     - Push to Main: Automatic validation and deployment of frontend updates
#     - Pull Requests: Comprehensive testing of proposed UI/UX changes
#     - Manual Dispatch: On-demand builds for frontend testing and performance validation
#     - Asset Updates: Automated validation when static assets or content changes
#
# üîß ENVIRONMENT VARIABLES:
#     - PROJECT_KEY: BookVerse project identifier for JFrog integration
#     - JFROG_URL: JFrog Platform URL for frontend artifact and evidence management
#     - GITHUB_TOKEN: GitHub authentication for repository operations
#     - CDN_CONFIG: Content delivery network configuration for asset distribution
#
# üìà SUCCESS CRITERIA:
#     - Build Tests: All frontend builds complete successfully with optimization
#     - Performance Tests: Lighthouse scores meet 95+ targets for all metrics
#     - Accessibility Tests: WCAG 2.1 AA compliance validation passes
#     - Security Compliance: Frontend security scanning and vulnerability assessment
#     - Integration Tests: Seamless operation with all backend services and APIs
#
# üåê FRONTEND SPECIFIC FEATURES:
#     - Modern JavaScript: ES2022+ with TypeScript support and advanced bundling
#     - Responsive Design: Mobile-first approach with adaptive layouts and touch optimization
#     - Performance Optimization: Lazy loading, code splitting, and resource preloading
#     - PWA Capabilities: Service worker, offline support, and app-like experience
#     - SEO Excellence: Server-side rendering preparation and metadata optimization
#     - Analytics Integration: User behavior tracking and conversion measurement
#
# Authors: BookVerse Platform Team
# Version: 1.0.0
#
name: CI

# üîÑ Concurrency Control: Ensures only one CI build runs per repository at a time
# Prevents frontend asset conflicts and ensures consistent UI/UX testing results
concurrency:
  group: ci-${{ vars.PROJECT_KEY }}-${{ github.repository }}
  cancel-in-progress: true

# ‚ö° Workflow Triggers: Defines when the frontend CI pipeline should execute
# Optimized for continuous validation of UI/UX and frontend performance operations
on:
  # üì§ Push Events: Automatic validation when frontend code is updated on main branch
  push:
    branches: [main]
  
  # üîç Pull Request Events: Comprehensive testing of proposed frontend changes
  # Ensures UI/UX quality and performance before merging into main branch
  pull_request:
    branches: [main]
  
  # üéõÔ∏è Manual Dispatch: On-demand execution for frontend testing and performance validation
  # Supports manual deployment and UI/UX optimization validation scenarios
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for manual CI trigger'
        required: false
        default: 'Manual testing'
        type: string
      force_app_version:
        description: 'Force application version creation (override commit filter)'
        required: false
        default: true
        type: boolean

jobs:
  # üîç Job: Intelligent Commit Analysis for Frontend Deployment Decisions
  # This job analyzes commits to determine whether frontend changes warrant
  # creating new application versions for deployment. Critical for managing
  # UI/UX consistency and ensuring safe deployment of frontend updates.
  # Key outputs: deployment decision, commit classification, business reasoning
  analyze-commit:
    name: "Demo: Analyze Commit (Shared Script)"
    runs-on: ubuntu-latest
    outputs:
      create_app_version: ${{ steps.demo-filter.outputs.create_app_version }}
      decision_reason: ${{ steps.demo-filter.outputs.decision_reason }}
      commit_type: ${{ steps.demo-filter.outputs.commit_type }}
    steps:
      # üì• Setup: Repository checkout for frontend system analysis
      # Fetches web UI service source code with commit history
      # for intelligent analysis of frontend assets and UI/UX changes
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Shallow clone with history for commit comparison

      # üìö Setup: Infrastructure checkout for shared frontend analysis scripts
      # Retrieves centralized DevOps scripts optimized for frontend workflows
      # and UI/UX change detection patterns from bookverse-infra
      - name: "[Setup] Checkout bookverse-infra for shared scripts"
        uses: actions/checkout@v4
        with:
          repository: yonatanp-jfrog/bookverse-infra
          path: bookverse-infra
      
      # üß† Analysis: Frontend-optimized commit analysis for deployment decisions
      # Executes sophisticated frontend change detection to determine
      # if UI/UX or asset updates warrant new application versions
      # Critical for frontend deployment pipeline and customer experience management
      - name: "[Demo] Commit Analysis (Shared Script - Web Adapted)"
        id: demo-filter
        env:
          GITHUB_EVENT_INPUTS_FORCE_APP_VERSION: ${{ inputs.force_app_version }}
        run: |
          echo "üéØ WEB SERVICE: Analyzing commit using shared bookverse-devops script"
          echo "üìù Commit: ${GITHUB_SHA:0:8}"
          echo "üí¨ Message: $(git log -1 --pretty=%B)"
          echo "üìÅ Changed files: $(git diff --name-only HEAD~1 | wc -l) files"
          echo "üåê Frontend note: Web services create application versions for UI releases"
          echo ""
          
          chmod +x bookverse-infra/libraries/bookverse-devops/scripts/analyze-commit.sh
          bookverse-infra/libraries/bookverse-devops/scripts/analyze-commit.sh

  # üèóÔ∏è Job: Comprehensive Frontend Build, Test, and Artifact Publication
  # This job executes the complete CI pipeline for the web UI system,
  # including frontend asset optimization, performance testing, accessibility
  # validation, and artifact publication. Critical for ensuring customer experience
  # quality and deployment readiness across all BookVerse frontend environments.
  # Key outputs: build artifacts, performance metrics, application versions, asset bundles
  build-test-publish:
    name: "Build & Test (Always Runs)"
    needs: analyze-commit
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    # üîê Security: OIDC permissions for JFrog authentication and frontend artifact publishing
    # Enables secure, passwordless authentication for frontend asset management
    permissions:
      contents: read      # Repository content access for source code
      id-token: write    # OIDC token generation for JFrog authentication
    outputs:
      build_name: ${{ steps.set-build-info.outputs.build_name }}
      build_started_timestamp: ${{ steps.publish-build-info.outputs.build_started_timestamp }}
      build_number: ${{ steps.set-build-info.outputs.build_number }}
      app_version: ${{ steps.set-app-version.outputs.app_version }}
      jf_oidc_token: ${{ steps.extract-token.outputs.oidc_token }}

    steps:
      # üì• Setup: Repository checkout for frontend system source code
      # Retrieves complete web UI service codebase including
      # frontend assets, build configurations, and UI/UX implementations
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      # üìö Setup: Infrastructure library checkout for frontend evidence collection
      # Fetches shared libraries optimized for frontend artifact management,
      # cryptographic evidence collection, and UI/UX validation patterns
      - name: "[Setup] Checkout bookverse-infra for shared scripts"
        uses: actions/checkout@v4
        with:
          repository: yonatanp-jfrog/bookverse-infra
          path: bookverse-infra

      - name: "[Info] Trigger Information"
        run: |
          echo "üöÄ CI Pipeline: Build & Test Phase"
          echo "üìã Commit Analysis Result: ${{ needs.analyze-commit.outputs.commit_type }}"
          echo "üí° Decision: ${{ needs.analyze-commit.outputs.decision_reason }}"
          echo "üéØ Create App Version: ${{ needs.analyze-commit.outputs.create_app_version }}"
          echo "üë§ Triggered by: ${{ github.actor }}"
          echo "üïê Timestamp: $(date -u)"

      - name: "[Setup] Build Info"
        id: set-build-info
        run: |
          BUILD_NAME="${{ github.event.repository.name }}_${{ github.workflow }}_${{ github.job }}"
          BUILD_NUMBER="${{ github.run_number }}-${{ github.run_attempt }}"
          echo "BUILD_NAME=$BUILD_NAME" >> $GITHUB_ENV
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          echo "build_name=$BUILD_NAME" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "SERVICE_NAME=web" >> $GITHUB_ENV
          echo "APPLICATION_KEY=bookverse-web" >> $GITHUB_ENV

      - name: "[Setup] JFrog CLI"
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        id: jfrog-cli-auth
        with:
          oidc-provider-name: bookverse-web-github
          oidc-audience: ${{ vars.JFROG_URL }}
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}

      - name: "[Setup] Extract OIDC Token from JFrog CLI"
        id: extract-token
        run: |
          echo "üîç Extracting OIDC token from JFrog CLI step output..."
          
          OIDC_TOKEN="${{ steps.jfrog-cli-auth.outputs.oidc-token }}"
          if [[ -n "$OIDC_TOKEN" && "$OIDC_TOKEN" != "null" ]]; then
            echo "‚úÖ Successfully retrieved OIDC token from JFrog CLI step output (oidc-token)"
            echo "üìã Token length: ${#PROMOTION_OIDC_TOKEN}"
          else
            echo "‚ùå OIDC token not available from JFrog CLI step output (oidc-token)"
            exit 1
          fi
          
          echo "oidc_token=$OIDC_TOKEN" >> $GITHUB_OUTPUT
          echo "JF_OIDC_TOKEN=$OIDC_TOKEN" >> $GITHUB_ENV
          
      - name: "[Setup] Verify JFrog Authentication"
        run: |
          echo "üîê Verifying JFrog CLI authentication and connectivity..."
          jf c show
          jf rt ping

      - name: "[Setup] Install Python dependencies"
        run: |
          pip install --user PyYAML setuptools wheel
          echo "‚úÖ Python dependencies installed"

      - name: "[Setup] Determine SemVer"
        id: set-app-version
        run: |
          set -euo pipefail
          SERVICE_NAME=${SERVICE_NAME:-$(echo ${{ github.event.repository.name }} | sed 's/bookverse-//')}
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          echo "üîç Using OIDC token directly from JFrog CLI step output for semver determination..."
          
          OIDC_TOKEN="${{ steps.jfrog-cli-auth.outputs.oidc-token }}"
          if [[ -z "$OIDC_TOKEN" ]]; then
            echo "‚ùå OIDC token not available from JFrog CLI step" >&2
            exit 1
          fi
          
          echo "‚úÖ OIDC token available from JFrog CLI step"
          echo "üìã Token length: ${#PROMOTION_OIDC_TOKEN}"
          echo "üìã Token starts with: ${OIDC_TOKEN:0:10}..."
          echo "üìã Using shared semver logic from bookverse-infra"
          
          INFRA_SCRIPTS_PATH="bookverse-infra/libraries/bookverse-devops/scripts"
          if [[ -f "$INFRA_SCRIPTS_PATH/determine-semver.sh" ]]; then
            cp "$INFRA_SCRIPTS_PATH/determine-semver.sh" .
            cp "$INFRA_SCRIPTS_PATH/semver_versioning.py" .
            chmod +x determine-semver.sh
            echo "‚úÖ Using shared semver scripts from bookverse-infra"
          else
            echo "‚ùå Shared semver scripts not found in bookverse-infra at $INFRA_SCRIPTS_PATH" >&2
            exit 1
          fi
          
          echo "üîç Calculating versions for all packages using shared logic..."
          SEMVER_OUTPUT=$(./determine-semver.sh \
            --application-key "$APPLICATION_KEY" \
            --version-map "./config/version-map.yaml" \
            --jfrog-url "${{ vars.JFROG_URL }}" \
            --jfrog-token "$OIDC_TOKEN" \
            --project-key "${{ vars.PROJECT_KEY }}" \
            --packages "web,web-assets" \
            --verbose)
          
          JSON_LINE=$(echo "$SEMVER_OUTPUT" | grep '{"application_key"')
          APP_VERSION=$(echo "$JSON_LINE" | jq -r '.app_version')
          if [[ -z "$APP_VERSION" || "$APP_VERSION" == "null" ]]; then
            echo "‚ùå Failed to extract APP_VERSION from semver output" >&2
            echo "üìã Semver output: $SEMVER_OUTPUT" >&2
            exit 1
          fi
          echo "üìã Extracting individual package versions from JSON output:"
          
          WEB_VERSION=$(echo "$JSON_LINE" | jq -r '.package_tags.web // empty')
          WEB_ASSETS_VERSION=$(echo "$JSON_LINE" | jq -r '.package_tags."web-assets" // empty')
          
          for pkg_name in "WEB" "WEB_ASSETS"; do
            pkg_var="${pkg_name}_VERSION"
            if [[ -z "${!pkg_var}" ]]; then
              echo "‚ùå Failed to determine ${pkg_var} from semver script" >&2
              echo "üìã Available package_tags: $(echo "$JSON_LINE" | jq -r '.package_tags | keys[]')" >&2
              exit 1
            fi
          done
          
          echo "WEB_VERSION=$WEB_VERSION" >> $GITHUB_ENV
          echo "WEB_ASSETS_VERSION=$WEB_ASSETS_VERSION" >> $GITHUB_ENV
          
          echo "üè∑Ô∏è Package Versions:"
          echo "  üê≥ web (Docker): $WEB_VERSION"
          echo "  üåê web-assets (Generic): $WEB_ASSETS_VERSION"
          echo "  üè∑Ô∏è Application: $APP_VERSION"
          echo "  üî¢ Build Number (for build info): $BUILD_NUMBER"
          
          DOCKER_TAG_VAR="DOCKER_TAG_$(echo "$SERVICE_NAME" | tr '[:lower:]' '[:upper:]' | tr '-' '_')"
          if [[ -n "${!DOCKER_TAG_VAR:-}" ]]; then
            IMAGE_TAG="${!DOCKER_TAG_VAR}"
          else
            IMAGE_TAG="$WEB_VERSION"
          fi
          
          REGISTRY_URL="${{ vars.DOCKER_REGISTRY }}"
          REPO_KEY="${{ vars.PROJECT_KEY }}-$SERVICE_NAME-internal-docker-nonprod-local"
          IMAGE_NAME="$REGISTRY_URL/$REPO_KEY/$SERVICE_NAME:$IMAGE_TAG"
          
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT
          echo "APPLICATION_KEY=$APPLICATION_KEY" >> $GITHUB_ENV

      # üì¶ Setup: Node.js environment for modern frontend development
      # Configures Node.js 20 with npm caching for optimal frontend build
      # performance and modern JavaScript/TypeScript compilation
      - name: "[Setup] Node"
        uses: actions/setup-node@v4
        with:
          node-version: '20'  # Latest LTS for modern frontend tooling and Vite optimization
          cache: 'npm'       # Accelerated dependency installation for frontend packages

      # üì¶ Dependencies: Frontend package installation with production optimization
      # Installs all required frontend dependencies for UI/UX development
      # and build processes using clean, reproducible npm ci approach
      - name: "[Build] Install dependencies"
        run: |
          # üîß Clean install: Reproducible dependency installation for frontend builds
          # Uses package-lock.json for exact version matching and build consistency
          npm ci --no-audit --fund=false

      # üèóÔ∏è Build: Frontend asset compilation and optimization
      # Executes Vite build process for production-ready JavaScript, CSS,
      # and static assets with tree-shaking and performance optimization
      - name: "[Build] Build web assets"
        run: |
          # üåê Asset compilation: Production build with Vite optimization
          # Generates minified, bundled, and optimized frontend assets for deployment
          npm run build --if-present

      # üì¶ Artifacts: Web asset packaging for distribution and deployment
      # Creates compressed archive of production-ready frontend assets
      # optimized for CDN deployment and high-performance content delivery
      - name: "[Build] Generic Artifact - Web Assets"
        run: |
          set -euo pipefail
          SERVICE_NAME=${SERVICE_NAME:-$(echo ${{ github.event.repository.name }} | sed 's/bookverse-//')}
          
          echo "Using web-assets package version: $WEB_ASSETS_VERSION"
          
          # üì¶ Asset packaging: Create deployment-ready frontend asset archive
          # Packages optimized frontend assets for CDN distribution and deployment
          echo "üì¶ Creating web-assets.tar.gz package from dist/ folder"
          
          tar -czf "web-assets-$WEB_ASSETS_VERSION.tar.gz" -C dist .
          
          GENERIC_REPO="${{ vars.PROJECT_KEY }}-$SERVICE_NAME-internal-generic-nonprod-local"
          jf rt upload "web-assets-$WEB_ASSETS_VERSION.tar.gz" "$GENERIC_REPO/$SERVICE_NAME/assets/$WEB_ASSETS_VERSION/web-assets-$WEB_ASSETS_VERSION.tar.gz" \
            --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER" --project "${{ vars.PROJECT_KEY }}"
          echo "‚úÖ Web assets package uploaded with version $WEB_ASSETS_VERSION"

      - name: "[Evidence] Web Assets Package"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
          EVIDENCE_KEY_ALIAS: ${{ vars.EVIDENCE_KEY_ALIAS }}
        run: |
          echo "üì¶ Generating evidence for web assets package using shared library"
          echo "üì¶ Target Package: web-assets:$WEB_ASSETS_VERSION"
          echo "üîê Evidence will be cryptographically signed for compliance verification"
          
          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          
          export PACKAGE_NAME="web-assets-$WEB_ASSETS_VERSION.tar.gz"
          export PACKAGE_VERSION="$WEB_ASSETS_VERSION"
          attach_generic_package_evidence "$PACKAGE_NAME" "$PACKAGE_VERSION"
          
          echo "‚úÖ Web assets package evidence attached via shared library: config-bundle"

      - name: "[Build] Docker Registry Authentication"
        env:
          OIDC_TOKEN: ${{ steps.jfrog-cli-auth.outputs.oidc-token }}
          REGISTRY_URL: ${{ vars.JFROG_URL }}
        run: |
          set -euo pipefail
          
          echo "üîê Authenticating Docker with JFrog registry..."
          
          if [[ -z "$OIDC_TOKEN" ]]; then
            echo "‚ùå OIDC token not provided" >&2
            echo "üîç Available step outputs:" >&2
            echo "  jfrog-cli-auth.outputs: ${{ toJSON(steps.jfrog-cli-auth.outputs) }}" >&2
            exit 1
          fi
          
          if [[ -z "$REGISTRY_URL" ]]; then
            echo "‚ùå Registry URL not provided" >&2
            exit 1
          fi
          
          DOCKER_REGISTRY="${REGISTRY_URL}"
          DOCKER_REGISTRY="${DOCKER_REGISTRY#https://}"
          DOCKER_REGISTRY="${DOCKER_REGISTRY#https://}"
          DOCKER_REGISTRY="${DOCKER_REGISTRY%/}"
          
          echo "üê≥ Registry hostname: $DOCKER_REGISTRY"
          
          echo "üîç Parsing JWT token for username..."
          TOKEN_PAYLOAD=$(echo "$OIDC_TOKEN" | cut -d. -f2)
          
          case $((${#TOKEN_PAYLOAD} % 4)) in
            2) TOKEN_PAYLOAD="${TOKEN_PAYLOAD}==" ;;
            3) TOKEN_PAYLOAD="${TOKEN_PAYLOAD}=" ;;
          esac
          
          CLAIMS=$(echo "$TOKEN_PAYLOAD" | tr '_-' '/+' | base64 -d 2>/dev/null || true)
          if [[ -z "$CLAIMS" ]]; then
            echo "‚ùå Failed to decode JWT token payload" >&2
            exit 1
          fi
          
          DOCKER_USER=$(echo "$CLAIMS" | jq -r '.username // .sub // .subject // "oauth2_access_token"' 2>/dev/null || echo "oauth2_access_token")
          
          if [[ "$DOCKER_USER" == *"/users/"* ]]; then
            DOCKER_USER=${DOCKER_USER##*/users/}
            echo "üîç Extracted username from JFrog path format"
          fi
          
          if [[ -z "$DOCKER_USER" || "$DOCKER_USER" == "null" ]]; then
            DOCKER_USER="oauth2_access_token"
            echo "üîç Using fallback username: oauth2_access_token"
          fi
          
          echo "üìã Authentication details:"
          echo "  ‚Ä¢ Registry: $DOCKER_REGISTRY"
          echo "  ‚Ä¢ Username: $DOCKER_USER"
          echo "  ‚Ä¢ Token: ${OIDC_TOKEN:0:10}*** (truncated for security)"
          
          echo "üê≥ Performing Docker registry login..."
          if echo "$OIDC_TOKEN" | docker login "$DOCKER_REGISTRY" -u "$DOCKER_USER" --password-stdin; then
            echo "‚úÖ Docker authentication successful"
          else
            echo "‚ùå Docker authentication failed" >&2
            echo "üîç Debugging information:"
            echo "  ‚Ä¢ Registry: $DOCKER_REGISTRY"
            echo "  ‚Ä¢ Username: $DOCKER_USER"
            echo "  ‚Ä¢ Token length: ${#OIDC_TOKEN}"
            echo "  ‚Ä¢ Token prefix: ${OIDC_TOKEN:0:20}..."
            exit 1
          fi

      - name: "[Build] Web image"
        run: |
          set -euo pipefail
          SERVER_ID="${SETUP_JFROG_CLI_SERVER_IDS:-setup-jfrog-cli-server}"
          jf c use "$SERVER_ID" || true
          export JF_PROJECT="${{ vars.PROJECT_KEY }}"
          export JFROG_CLI_BUILD_PROJECT="${{ vars.PROJECT_KEY }}"

          echo "Using precomputed image tag: $IMAGE_TAG"
          echo "Using precomputed image name: $IMAGE_NAME"

          docker build --tag "$IMAGE_NAME" .
          
          jf docker push "$IMAGE_NAME" \
            --build-name "$BUILD_NAME" \
            --build-number "$BUILD_NUMBER" \
            --project "${{ vars.PROJECT_KEY }}"

          echo "DOCKER_BUILD_PUSH_STATUS=SUCCESS" >> $GITHUB_ENV
          echo "‚úÖ Built, pushed, and associated web Docker image with build-info"

      - name: "[Evidence] Web Image Package Evidence"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
          EVIDENCE_KEY_ALIAS: ${{ vars.EVIDENCE_KEY_ALIAS }}
        run: |
          echo "üõ°Ô∏è Generating evidence for web image package using shared library"
          echo "üì¶ Target Package: web:$WEB_VERSION"
          echo "üîê Evidence will be cryptographically signed for compliance verification"
          
          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          
          export PACKAGE_NAME="web"
          export PACKAGE_VERSION="$WEB_VERSION"
          attach_docker_package_evidence "$PACKAGE_NAME" "$PACKAGE_VERSION"
          
          echo "‚úÖ Web image package evidence attached via shared library: pytest-results, sast-scan"

      - name: "[Build Info] Publish"
        id: publish-build-info
        run: |
          jf rt bag --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"
          jf rt bce --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"
          if BUILD_PUBLISH_RESULT=$(jf rt bp --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER" 2>&1); then
            echo "BUILD_INFO_PUBLISH_STATUS=SUCCESS" >> $GITHUB_ENV
            
            BUILD_UI_URL=$(echo "$BUILD_PUBLISH_RESULT" | grep -o 'Browse it in Artifactory under https://[^[:space:]]*' | sed 's/Browse it in Artifactory under //' | head -1 || echo "$BUILD_PUBLISH_RESULT" | grep -o '"buildInfoUiUrl": *"[^"]*"' | sed 's/.*"buildInfoUiUrl": *"\([^"]*\)".*/\1/' | head -1 || echo "")
            if [[ -n "$BUILD_UI_URL" ]]; then
              EPOCH_MS=$(echo "$BUILD_UI_URL" | sed -n 's|.*/builds/[^/]*/[^/]*/\([0-9]*\)/published.*|\1|p')
              
              if [[ -n "$EPOCH_MS" && "$EPOCH_MS" =~ ^[0-9]+$ ]]; then
                EPOCH_SEC=$((EPOCH_MS / 1000))
                MILLISECS=$((EPOCH_MS % 1000))
                BUILD_STARTED_TIMESTAMP=$(date -u -r "$EPOCH_SEC" "+%Y-%m-%dT%H:%M:%S" 2>/dev/null || date -u -d "@$EPOCH_SEC" "+%Y-%m-%dT%H:%M:%S")
                BUILD_STARTED_TIMESTAMP="${BUILD_STARTED_TIMESTAMP}.$(printf "%03d" $MILLISECS)+0000"
                
                echo "BUILD_STARTED_TIMESTAMP=$BUILD_STARTED_TIMESTAMP" >> $GITHUB_ENV
                echo "build_started_timestamp=$BUILD_STARTED_TIMESTAMP" >> $GITHUB_OUTPUT
                echo "‚úÖ Extracted timestamp from build publish result: $BUILD_STARTED_TIMESTAMP"
              else
                echo "‚ö†Ô∏è Could not extract epoch milliseconds from build UI URL: $BUILD_UI_URL"
                FALLBACK_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)
                echo "BUILD_STARTED_TIMESTAMP=$FALLBACK_TIMESTAMP" >> $GITHUB_ENV
                echo "build_started_timestamp=$FALLBACK_TIMESTAMP" >> $GITHUB_OUTPUT
              fi
            else
              echo "‚ö†Ô∏è Could not extract build UI URL from JFrog CLI output"
              FALLBACK_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)
              echo "BUILD_STARTED_TIMESTAMP=$FALLBACK_TIMESTAMP" >> $GITHUB_ENV
              echo "build_started_timestamp=$FALLBACK_TIMESTAMP" >> $GITHUB_OUTPUT
            fi
            echo "‚úÖ Build info published successfully"
          else
            echo "BUILD_INFO_PUBLISH_STATUS=FAILED" >> $GITHUB_ENV
            echo "‚ùå Failed to publish build info" >&2
            exit 1
          fi

      - name: "[Evidence] Build Evidence"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
          EVIDENCE_KEY_ALIAS: ${{ vars.EVIDENCE_KEY_ALIAS }}
        run: |
          echo "üèóÔ∏è Generating evidence for build-info"
          
          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          
          attach_build_evidence
          
          echo "‚úÖ Build evidence attached: fossa-license-scan, sonar-quality-gate"

  create-promote:
    name: "Create Application Version & Promote (Conditional)"
    runs-on: ubuntu-latest
    needs: [analyze-commit, build-test-publish]
    if: needs.analyze-commit.outputs.create_app_version == 'true' && needs.build-test-publish.result == 'success'
    
    permissions:
      contents: read
      id-token: write

    env:
      BUILD_NAME: ${{ needs.build-test-publish.outputs.build_name }}
      BUILD_NUMBER: ${{ needs.build-test-publish.outputs.build_number }}
      BUILD_INFO_REPO: "artifactory-build-info"
      SERVICE_NAME: "web"
      APPLICATION_KEY: "bookverse-web"
      APP_VERSION: ${{ needs.build-test-publish.outputs.app_version }}
      BUILD_STARTED_TIMESTAMP: ${{ needs.build-test-publish.outputs.build_started_timestamp }}
      EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
      EVIDENCE_KEY_ALIAS: ${{ vars.EVIDENCE_KEY_ALIAS }}
      JFROG_URL: ${{ vars.JFROG_URL }}
      JF_URL: ${{ vars.JFROG_URL }}
      PROJECT_KEY: ${{ vars.PROJECT_KEY }}
      STAGES_STR: "DEV QA STAGING PROD"
      FINAL_STAGE: "PROD"
      ALLOW_RELEASE: "true"
      RELEASE_INCLUDED_REPO_KEYS: '["bookverse-web-internal-docker-release-local","bookverse-web-internal-generic-release-local"]'

    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Setup] Checkout bookverse-infra for shared scripts"
        uses: actions/checkout@v4
        with:
          repository: yonatanp-jfrog/bookverse-infra
          path: bookverse-infra

      - name: "[Setup] JFrog CLI"
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        id: jfrog-cli-auth
        with:
          oidc-provider-name: bookverse-web-github
          oidc-audience: ${{ vars.JFROG_URL }}
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}

      - name: "[Setup] Extract OIDC Token for Promotion Job"
        id: extract-promotion-token
        run: |
          echo "üîç Extracting OIDC token from JFrog CLI step output for promotion job..."
          
          PROMOTION_OIDC_TOKEN="${{ steps.jfrog-cli-auth.outputs.oidc-token }}"
          if [[ -n "$PROMOTION_OIDC_TOKEN" && "$PROMOTION_OIDC_TOKEN" != "null" ]]; then
            echo "‚úÖ Successfully retrieved OIDC token from JFrog CLI step output (oidc-token)"
            echo "üìã Token length: ${#PROMOTION_OIDC_TOKEN}"
            echo "promotion_oidc_token=$PROMOTION_OIDC_TOKEN" >> $GITHUB_OUTPUT
            echo "JF_OIDC_TOKEN=$PROMOTION_OIDC_TOKEN" >> $GITHUB_ENV
          else
            echo "‚ùå OIDC token not available from JFrog CLI step output (oidc-token) in promotion job" >&2
            exit 1
          fi
          echo "‚úÖ OIDC token exchange completed using shared bookverse-devops script"

      - name: "[Setup] Use App Version from Build Job"
        id: use-app-version
        run: |
          APP_VERSION="${{ needs.build-test-publish.outputs.app_version }}"
          
          if [[ -z "$APP_VERSION" ]]; then
            echo "‚ùå Missing app_version from build-test-publish job output" >&2
            exit 1
          fi
          
          echo "üè∑Ô∏è Using Application Version from build job: $APP_VERSION"
          echo "üìã This version is already associated with the published build info"
          echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT

      - name: "[Diag] Build Info contents"
        run: |
          set -euo pipefail
          echo "üîé Fetching build info to confirm artifacts are present"
          ENC_BUILD_NAME=$(printf '%s' "$BUILD_NAME" | jq -sRr @uri)
          ENC_BUILD_NUMBER=$(printf '%s' "$BUILD_NUMBER" | jq -sRr @uri)
          URL="${{ vars.JFROG_URL }}/artifactory/api/build/${ENC_BUILD_NAME}/${ENC_BUILD_NUMBER}?project=${{ vars.PROJECT_KEY }}"
          echo "GET $URL"
          curl -sS -H "Authorization: Bearer ${{ steps.extract-promotion-token.outputs.promotion_oidc_token }}" -H "Accept: application/json" "$URL" \
            | jq '.buildInfo.modules // [] | map({id, artifacts: (.artifacts // [] | length)})'

      - name: "[Create] Application Version"
        run: |
          echo "üöÄ Creating AppTrust application version: $APP_VERSION"

          TAG_OPTIONS=(
            "release"
            "hotfix"
            "feature"
            "bugfix"
            "enhancement"
            "security"
            "performance"
            "refactor"
            "experimental"
            "maintenance"
            "integration"
            "documentation"
            "stable"
            "beta"
            "alpha"
            "critical"
            "patch"
            "minor"
            "major"
            "cleanup"
          )

          TAG_INDEX=$((${GITHUB_RUN_NUMBER:-0} % ${#TAG_OPTIONS[@]}))
          APP_TAG="${TAG_OPTIONS[$TAG_INDEX]}"
          echo "üè∑Ô∏è Application Version Tag (demo simulation): $APP_TAG"

          APP_VERSION_PAYLOAD='{"version":"'$APP_VERSION'","tag":"'$APP_TAG'","sources":{"builds":[{"name":"'$BUILD_NAME'","number":"'$BUILD_NUMBER'","repository_key":"'${{ vars.PROJECT_KEY }}'-build-info","include_dependencies":false}]}}'

          echo "üì¶ Application Key: $APPLICATION_KEY"
          echo "üìù Payload:"; echo "$APP_VERSION_PAYLOAD" | jq . || echo "$APP_VERSION_PAYLOAD"
          if [ -f .github/scripts/http_debug.sh ]; then source .github/scripts/http_debug.sh; fi
          if ! declare -f print_request_debug >/dev/null 2>&1; then
            print_request_debug() {
              local method="$1"; local url="$2"; local body="${3:-}"; local level="${HTTP_DEBUG_LEVEL:-basic}"
              [ "$level" = "none" ] && return 0
              local show_project_header=false
              if [[ "${DEBUG_INCLUDE_PROJECT_HEADER:-}" == "true" || "${DEBUG_INCLUDE_PROJECT_HEADER:-}" == "1" ]]; then
                show_project_header=true
              else
                if [[ "$url" == *"/apptrust/api/"* ]]; then
                  if [[ "$url" == *"/promote"* || "$url" == *"/release"* ]]; then
                    show_project_header=false
                  else
                    show_project_header=true
                  fi
                fi
              fi
              local show_content_type=false
              if [[ "$method" == "POST" ]]; then
                show_content_type=true
              fi
              echo "---- Request debug (${level}) ----"
              echo "Method: ${method}"
              echo "URL: ${url}"
              echo "Headers:"
              echo "  Authorization: Bearer ***REDACTED***"
              if $show_project_header && [[ -n "${PROJECT_KEY:-}" ]]; then echo "  X-JFrog-Project: ${PROJECT_KEY}"; fi
              if $show_content_type; then echo "  Content-Type: application/json"; fi
              echo "  Accept: application/json"
              if [ -n "$body" ] && [ "$level" = "verbose" ]; then
                echo "Body: ${body}"
              fi
              echo "-----------------------"
            }
          fi
          echo "üîó Curl (sanitized): curl -X POST '${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions/?async=false' -H 'Authorization: Bearer ***' -H 'Content-Type: application/json' -H 'Accept: application/json' -d '<payload>'"
          DEBUG_INCLUDE_PROJECT_HEADER=false print_request_debug "POST" "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions/?async=false" "<payload>"

          TOKEN="${{ steps.extract-promotion-token.outputs.promotion_oidc_token }}"
          if [ -z "$TOKEN" ]; then
            echo "‚ùå Missing OIDC token from promotion job JFrog CLI setup" >&2
            exit 1
          fi
          echo "‚úÖ Using OIDC token for application version creation"
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq >/dev/null; fi

          echo "üîç Preflight: ensuring application '$APPLICATION_KEY' exists"
          APP_GET_CODE=$(curl -s -o /dev/null -w '%{http_code}' "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY" \
            -H "Authorization: Bearer $TOKEN" -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" -H "Accept: application/json")
          if [ "$APP_GET_CODE" = "404" ]; then
            echo "üÜï Application not found; creating it"
            CREATE_APP_BODY=$(jq -n --arg name "BookVerse Web" --arg key "$APPLICATION_KEY" --arg proj "${{ vars.PROJECT_KEY }}" '{application_name:$name, application_key:$key, project_key:$proj}')
            APP_CREATE_CODE=$(curl -s -o /tmp/app_create.json -w '%{http_code}' -X POST "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/" \
              -H "Authorization: Bearer $TOKEN" -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" -H "Content-Type: application/json" -H "Accept: application/json" \
              -d "$CREATE_APP_BODY")
            echo "üì® Create Application Response:"; cat /tmp/app_create.json || true
            if [ "$APP_CREATE_CODE" -lt 200 ] || [ "$APP_CREATE_CODE" -ge 300 ]; then
              echo "‚ùå Failed to create application (HTTP $APP_CREATE_CODE)"; exit 1
            fi
          fi

          BASE="${{ vars.JFROG_URL }}/apptrust/api/v1"
          RESP_BODY=$(mktemp)
          HTTP_STATUS=$(curl -sS -L -o "$RESP_BODY" -w "%{http_code}" -X POST \
            "$BASE/applications/$APPLICATION_KEY/versions?async=false" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            -d "$APP_VERSION_PAYLOAD" \
            --fail-with-body || true)
          
          echo "üî¢ HTTP Status: $HTTP_STATUS"
          echo "üì® Response Body:"
          cat "$RESP_BODY" || true; echo
          
          if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 300 ]; then
            echo "‚úÖ Application version created successfully"
          elif [ "$HTTP_STATUS" = "409" ]; then
            echo "‚ö†Ô∏è Application version already exists; continuing"
          else
            echo "‚ùå Create application version failed (HTTP $HTTP_STATUS)"
            exit 1
          fi
          rm -f "$RESP_BODY"

      - name: "[Evidence] Application Version Evidence"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
          EVIDENCE_KEY_ALIAS: ${{ vars.EVIDENCE_KEY_ALIAS }}
        run: |
          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          
          attach_application_unassigned_evidence
          
          echo "‚úÖ Application version evidence attached: slsa-provenance, jira-release"

      - name: "[Promote & Evidence] DEV Stage"
        run: |
          echo "üöÄ Promoting to DEV stage and generating evidence"
          
           if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
             echo "‚ùå Missing JF_OIDC_TOKEN. Ensure OIDC exchange step succeeded." >&2
             exit 1
           fi
           echo "‚úÖ Using JF_OIDC_TOKEN for DEV promotion"
          
          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          setup_promotion_environment
          
          if advance_one_step; then
            echo "‚úÖ Successfully promoted to DEV"
          else
            echo "‚ùå Failed to promote to DEV"
            exit 1
          fi
          
          attach_application_dev_evidence
          echo "‚úÖ DEV stage evidence attached: smoke-tests"

      - name: "[Promote & Evidence] QA Stage"
        run: |
          echo "üöÄ Promoting to QA stage and generating evidence"
          
          if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
            echo "‚ùå Missing JF_OIDC_TOKEN. Ensure OIDC exchange step succeeded." >&2
            exit 1
          fi
          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          setup_promotion_environment
          
          if advance_one_step; then
            echo "‚úÖ Successfully promoted to QA"
          else
            echo "‚ùå Failed to promote to QA"
            exit 1
          fi
          
          attach_application_qa_evidence
          echo "‚úÖ QA stage evidence attached: dast-scan, api-tests"

      - name: "[Promote & Evidence] STAGING Stage"
        run: |
          echo "üöÄ Promoting to STAGING stage and generating evidence"
          
          if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
            echo "‚ùå Missing JF_OIDC_TOKEN. Ensure OIDC exchange step succeeded." >&2
            exit 1
          fi
          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          setup_promotion_environment
          
          if advance_one_step; then
            echo "‚úÖ Successfully promoted to STAGING"
          else
            echo "‚ùå Failed to promote to STAGING"
            exit 1
          fi
          
          attach_application_staging_evidence
          echo "‚úÖ STAGING stage evidence attached: iac-scan, pentest, change-approval"

      - name: "[Promote & Evidence] PROD Stage"
        run: |
          echo "üöÄ Promoting to PROD stage and generating evidence"
          
          if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
            echo "‚ùå Missing JF_OIDC_TOKEN. Ensure OIDC exchange step succeeded." >&2
            exit 1
          fi
          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          setup_promotion_environment
          
          if advance_one_step; then
            echo "‚úÖ Successfully promoted to PROD"
          else
            echo "‚ùå Failed to promote to PROD"
            exit 1
          fi

          attach_application_prod_evidence
          echo "‚úÖ PROD stage evidence attached: deployment-verification"
          
          source bookverse-infra/libraries/bookverse-devops/scripts/promote-lib.sh
          fetch_summary
          echo "RELEASE_STATUS=${RELEASE_STATUS:-}" >> $GITHUB_ENV
          
          echo "üéâ SUCCESS: Application version $APP_VERSION promoted to PROD with all evidence attached!"

      - name: "[Tags] Self-Healing Tag Management"
        run: |
          set -euo pipefail
          echo "üè• Running self-healing tag management for PROD release"
          
          if [[ "${RELEASE_STATUS:-}" != "RELEASED" && "${RELEASE_STATUS:-}" != "TRUSTED_RELEASE" ]]; then
            echo "‚ÑπÔ∏è Skipping tag management; not a successful PROD release (status: ${RELEASE_STATUS:-UNKNOWN})"
            exit 0
          fi
          
          echo "‚úÖ PROD release successful, running comprehensive tag validation and healing"
          
          export JFROG_URL='${{ vars.JFROG_URL }}'
          export PROJECT_KEY='${{ vars.PROJECT_KEY }}'
          export APPLICATION_KEY="$APPLICATION_KEY"
          
          source bookverse-infra/libraries/bookverse-devops/scripts/tag-management-lib.sh
          
          validate_and_heal_tags
          
          echo ""
          echo "üéØ Tag management completed for version $APP_VERSION"
          echo "üìã All versions now have correct tags based on their states:"
          echo "   - 'latest': Highest SemVer version in PROD"
          echo "   - 'quarantine': Versions that were rolled back"
          echo "   - 'valid': Other valid SemVer versions"
          echo "   - Non-SemVer versions: No special tags (ignored for 'latest')"

      - name: "üìä Enhanced Build Summary (bookverse-devops pattern)"
        if: always()
        run: |
          echo "
          echo "**Workflow:** ${{ github.workflow }} | **Run:** ${{ github.run_number }}-${{ github.run_attempt }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** \`${GITHUB_SHA:0:8}\` | **Branch:** \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "
          echo "- **Docker Images:**" >> $GITHUB_STEP_SUMMARY
          echo "  - üê≥ web: \`${{ env.IMAGE_TAG || 'N/A' }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Generic Artifacts:**" >> $GITHUB_STEP_SUMMARY
          echo "  - üåê web-assets: \`v${{ env.WEB_ASSETS_VERSION || 'N/A' }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Evidence Artifacts:** ‚úÖ Collected and uploaded" >> $GITHUB_STEP_SUMMARY
          echo "- **Build-Info:** ‚úÖ Published with all artifacts" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "
          echo "- **Version:** \`${{ env.APP_VERSION }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Lifecycle:** DEV ‚Üí QA ‚Üí STAGING ‚Üí PROD (Complete)" >> $GITHUB_STEP_SUMMARY
          echo "- **Evidence:** ‚úÖ All stages have evidence attached" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.analyze-commit.outputs.create_app_version }}" == "true" ]]; then
            echo "
            echo "Application version \`${{ env.APP_VERSION }}\` is now available in **PROD**." >> $GITHUB_STEP_SUMMARY
          else
            echo "
            echo "This commit created build-info artifacts only (no application version)." >> $GITHUB_STEP_SUMMARY
            echo "Use manual workflow dispatch with \`force_app_version=true\` to create an application version." >> $GITHUB_STEP_SUMMARY
          fi