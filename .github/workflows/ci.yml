name: CI

# DEMO-READY: Automatic triggers enabled for full CI/CD pipeline demonstration
# PRODUCTION NOTE: Real systems would have additional branch protection and approval gates
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for manual CI trigger'
        required: false
        default: 'Manual testing'
        type: string
      force_app_version:
        description: 'Force application version creation (override commit filter)'
        required: false
        default: true
        type: boolean

jobs:
  analyze-commit:
    name: "Demo: Analyze Commit (Demo-Optimized)"
    runs-on: ubuntu-latest
    outputs:
      create_app_version: ${{ steps.demo-filter.outputs.create_app_version }}
      decision_reason: ${{ steps.demo-filter.outputs.decision_reason }}
      commit_type: ${{ steps.demo-filter.outputs.commit_type }}
    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      - name: "[Demo] Commit Analysis (Optimized for Visibility)"
        id: demo-filter
        env:
          GITHUB_EVENT_INPUTS_FORCE_APP_VERSION: ${{ inputs.force_app_version }}
        run: |
          echo "🎯 DEMO MODE: Analyzing commit for CI/CD pipeline demonstration"
          echo "📝 Commit: ${GITHUB_SHA:0:8}"
          echo "💬 Message: $(git log -1 --pretty=%B)"
          echo "📁 Changed files: $(git diff --name-only HEAD~1 | wc -l) files"
          echo "🏭 Production note: Real systems would use conservative defaults"
          echo ""
          
          # Use our commit analysis script
          chmod +x ./scripts/analyze-commit.sh
          ./scripts/analyze-commit.sh

  build-test-publish:
    name: "Build & Test (Always Runs)"
    needs: analyze-commit
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    permissions:
      contents: read
      id-token: write
    outputs:
      build_name: ${{ steps.set-build-info.outputs.build_name }}
      build_started_timestamp: ${{ steps.publish-build-info.outputs.build_started_timestamp }}
      build_number: ${{ steps.set-build-info.outputs.build_number }}
      app_version: ${{ steps.set-app-version.outputs.app_version }}
      jf_access_token: ${{ steps.exchange-oidc.outputs.token }}

    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Info] Trigger Information"
        run: |
          echo "🚀 CI Pipeline: Build & Test Phase"
          echo "📋 Commit Analysis Result: ${{ needs.analyze-commit.outputs.commit_type }}"
          echo "💡 Decision: ${{ needs.analyze-commit.outputs.decision_reason }}"
          echo "🎯 Create App Version: ${{ needs.analyze-commit.outputs.create_app_version }}"
          echo "👤 Triggered by: ${{ github.actor }}"
          echo "🕐 Timestamp: $(date -u)"

      - name: "[Setup] Build Info"
        id: set-build-info
        run: |
          BUILD_NAME="${{ github.event.repository.name }}_${{ github.workflow }}_${{ github.job }}"
          BUILD_NUMBER="${{ github.run_number }}-${{ github.run_attempt }}"
          echo "BUILD_NAME=$BUILD_NAME" >> $GITHUB_ENV
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          echo "build_name=$BUILD_NAME" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "SERVICE_NAME=web" >> $GITHUB_ENV
          echo "APPLICATION_KEY=bookverse-web" >> $GITHUB_ENV

      - name: "[Setup] JFrog CLI"
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        with:
          version: latest
          oidc-provider-name: bookverse-web-github
          oidc-audience: ${{ vars.JFROG_URL }}
          disable-job-summary: true
          disable-auto-build-publish: true
          disable-auto-evidence-collection: false
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
          JFROG_CLI_BUILD_NAME: ${{ env.BUILD_NAME }}
          JFROG_CLI_BUILD_NUMBER: ${{ env.BUILD_NUMBER }}
          JFROG_CLI_BUILD_PROJECT: ${{ vars.PROJECT_KEY }}
          
      - name: "[Setup] Verify JFrog Authentication"
        run: |
          echo "🔐 Verifying JFrog CLI authentication and connectivity..."
          jf c show
          jf rt ping

      - name: "[Auth] Exchange OIDC and persist JF access token"
        id: exchange-oidc
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          PROJECT: ${{ vars.PROJECT_KEY }}
          PROVIDER_NAME: bookverse-web-github
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
          if [[ -z "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" || -z "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" ]]; then
            echo "❌ Missing GitHub OIDC request env vars" >&2; exit 1; fi
          GH_ID_TOKEN=$(curl -sS -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" \
            "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${JF_URL}" | jq -r .value)
          if [[ -z "$GH_ID_TOKEN" || "$GH_ID_TOKEN" == "null" ]]; then echo "❌ Failed to fetch GitHub ID token" >&2; exit 1; fi
          PAYLOAD=$(jq -n --arg jwt "$GH_ID_TOKEN" \
            --arg provider_name "$PROVIDER_NAME" \
            --arg project_key "$PROJECT" \
            --arg job_id "${{ github.job }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg repo "https://github.com/${{ github.repository }}" \
            --arg revision "${{ github.sha }}" \
            --arg branch "${{ github.ref_name }}" \
            '{
              grant_type:"urn:ietf:params:oauth:grant-type:token-exchange",
              subject_token_type:"urn:ietf:params:oauth:token-type:id_token",
              subject_token:$jwt,
              provider_name:$provider_name,
              project_key:$project_key,
              job_id:$job_id,
              run_id:$run_id,
              repo:$repo,
              revision:$revision,
              branch:$branch
            }')
          TOKEN=$(curl -sS -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "$JF_URL/access/api/v1/oidc/token" | jq -r .access_token)
          if [[ -z "$TOKEN" || "$TOKEN" == "null" ]]; then echo "❌ Failed to exchange OIDC token" >&2; exit 1; fi
          echo "JF_OIDC_TOKEN=$TOKEN" >> $GITHUB_ENV
          echo "JF_ACCESS_TOKEN=$TOKEN" >> $GITHUB_ENV
          echo "token=$TOKEN" >> $GITHUB_OUTPUT
          
          # Extract Docker username from token (same as inventory)
          PAY_PAD=$(echo "$TOKEN" | cut -d. -f2)
          PAY_PAD="${PAY_PAD}$(printf '%*s' $(( (4 - ${#PAY_PAD} % 4) % 4 )) | tr ' ' '=')"
          CLAIMS=$(echo "$PAY_PAD" | tr '_-' '/+' | base64 -d 2>/dev/null || true)
          DOCKER_USER=$(echo "$CLAIMS" | jq -r '.username // .sub // .subject // empty' 2>/dev/null || true)
          # If sub is in the form jfac@.../users/<username>, extract the trailing <username>
          if [[ "$DOCKER_USER" == *"/users/"* ]]; then
            DOCKER_USER=${DOCKER_USER##*/users/}
          fi
          if [[ -z "$DOCKER_USER" || "$DOCKER_USER" == "null" ]]; then DOCKER_USER="oauth2_access_token"; fi
          echo "Using docker username: $DOCKER_USER"
          REGISTRY_URL="${{ vars.DOCKER_REGISTRY }}"
          echo "$TOKEN" | docker login "$REGISTRY_URL" -u "$DOCKER_USER" --password-stdin
          echo "✅ JFrog access token obtained and Docker login completed"

      - name: "[Setup] Determine SemVer"
        id: set-app-version
        run: |
          set -euo pipefail
          SERVICE_NAME=${SERVICE_NAME:-$(echo ${{ github.event.repository.name }} | sed 's/bookverse-//')}
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          
          # Use the unified semver determination script
          chmod +x ./scripts/determine-semver.sh
          SEMVER_OUTPUT=$(./scripts/determine-semver.sh \
            --application-key "$APPLICATION_KEY" \
            --version-map "./config/version-map.yaml" \
            --jfrog-url "${{ vars.JFROG_URL }}" \
            --jfrog-token "$JF_OIDC_TOKEN" \
            --project-key "${{ vars.PROJECT_KEY }}" \
            --packages "$SERVICE_NAME" \
            --verbose)
          
          # Extract APP_VERSION from the Python script's JSON output
          APP_VERSION=$(echo "$SEMVER_OUTPUT" | grep '{"application_key"' | jq -r '.app_version')
          if [[ -z "$APP_VERSION" || "$APP_VERSION" == "null" ]]; then
            echo "❌ Failed to extract APP_VERSION from semver output" >&2
            exit 1
          fi
          
          # Set IMAGE_TAG to the Docker package tag
          DOCKER_TAG_VAR="DOCKER_TAG_$(echo "$SERVICE_NAME" | tr '[:lower:]' '[:upper:]' | tr '-' '_')"
          if [[ -n "${!DOCKER_TAG_VAR:-}" ]]; then
            IMAGE_TAG="${!DOCKER_TAG_VAR}"
          else
            IMAGE_TAG="$BUILD_NUMBER"
          fi
          
          # Update IMAGE_NAME with the determined tag
          REGISTRY_URL="${{ vars.DOCKER_REGISTRY }}"
          REPO_KEY="${{ vars.PROJECT_KEY }}-$SERVICE_NAME-internal-docker-nonprod-local"
          IMAGE_NAME="$REGISTRY_URL/$REPO_KEY/$SERVICE_NAME:$IMAGE_TAG"
          
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT
          echo "APPLICATION_KEY=$APPLICATION_KEY" >> $GITHUB_ENV

      - name: "[Setup] Node"
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: "[Build] Install dependencies"
        run: |
          npm ci --no-audit --fund=false

      - name: "[Build] Build web assets"
        run: |
          npm run build --if-present

      - name: "[Build] Docker image"
        run: |
          set -euo pipefail
          # Use JFrog CLI to authenticate pushes without requiring docker login
          SERVER_ID="${SETUP_JFROG_CLI_SERVER_IDS:-setup-jfrog-cli-server}"
          jf c use "$SERVER_ID" || true
          # Ensure project header is sent for OIDC-based commands like `jf docker`
          export JF_PROJECT="${{ vars.PROJECT_KEY }}"
          # Also set build project explicitly for JFrog CLI commands
          export JFROG_CLI_BUILD_PROJECT="${{ vars.PROJECT_KEY }}"

          # Using OIDC-based server configuration from setup action; no admin token required
          # Use precomputed IMAGE_TAG/IMAGE_NAME from set-app-version step to avoid drift
          REPO_KEY="${{ vars.PROJECT_KEY }}-$SERVICE_NAME-internal-docker-nonprod-local"
          REGISTRY_URL="${{ vars.DOCKER_REGISTRY }}"
          IMAGE_NAME="$REGISTRY_URL/$REPO_KEY/$SERVICE_NAME:$IMAGE_TAG"
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV
          echo "Using precomputed image tag: $IMAGE_TAG"

          # Build and push (plain docker) using subdomain host; then create build-info
          jf docker build --pull -t "$IMAGE_NAME" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER" .
          docker push "$IMAGE_NAME"

          # Build-info will be published in a later step via bag/bce/bp
          echo "DOCKER_BUILD_PUSH_STATUS=SUCCESS" >> $GITHUB_ENV
          echo "✅ Built and pushed Docker image (OIDC docker push + build-info)"

      - name: "[Build Info] Publish"
        id: publish-build-info
        run: |
          # Associate the pushed Docker image with the build-info before publishing
          REPO_KEY="${{ vars.PROJECT_KEY }}-$SERVICE_NAME-internal-docker-nonprod-local"
          echo "🔗 Adding docker image to build-info: image=$IMAGE_NAME repo=$REPO_KEY"
          # Resolve pushed image digest and write in required format: image:tag@sha256:...
          DIGEST=$(docker inspect "$IMAGE_NAME" --format='{{index .RepoDigests 0}}' 2>/dev/null | awk -F@ '{print $2}')
          if [[ -z "$DIGEST" || "$DIGEST" == "<no value>" ]]; then
            docker pull "$IMAGE_NAME" >/dev/null 2>&1 || true
            DIGEST=$(docker inspect "$IMAGE_NAME" --format='{{index .RepoDigests 0}}' 2>/dev/null | awk -F@ '{print $2}')
          fi
          if [[ -z "$DIGEST" || "$DIGEST" == "<no value>" ]]; then
            echo "❌ Could not resolve image digest for $IMAGE_NAME" >&2; exit 1
          fi
          echo "${IMAGE_NAME%@*}@${DIGEST}" > images.txt
          jf rt build-docker-create "$REPO_KEY" \
            --image-file images.txt \
            --build-name "$BUILD_NAME" \
            --build-number "$BUILD_NUMBER" \
            --project "${{ vars.PROJECT_KEY }}"
          
          jf rt bag --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"
          jf rt bce --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"
          if BUILD_PUBLISH_RESULT=$(jf rt bp --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"); then
            echo "BUILD_INFO_PUBLISH_STATUS=SUCCESS" >> $GITHUB_ENV
            
            # Extract timestamp from build publish result (optimized - no extra API call)
            # Parse the UI URL from JFrog CLI log output instead of non-existent JSON field
            BUILD_UI_URL=$(echo "$BUILD_PUBLISH_RESULT" | grep -o 'https://[^[:space:]]*builds/[^[:space:]]*' | head -1 || echo "")
            if [[ -n "$BUILD_UI_URL" ]]; then
              # Extract timestamp from URL path: .../builds/SERVICE_NAME/BUILD_NUMBER/TIMESTAMP
              BUILD_TIMESTAMP=$(echo "$BUILD_UI_URL" | sed -n 's|.*/builds/[^/]*/[^/]*/\([0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}T[0-9]\{2\}:[0-9]\{2\}:[0-9]\{2\}\.[0-9]\{3\}Z\).*|\1|p')
              if [[ -n "$BUILD_TIMESTAMP" ]]; then
                echo "BUILD_STARTED_TIMESTAMP=$BUILD_TIMESTAMP" >> $GITHUB_ENV
                echo "build_started_timestamp=$BUILD_TIMESTAMP" >> $GITHUB_OUTPUT
                echo "✅ Extracted build timestamp: $BUILD_TIMESTAMP"
              else
                echo "⚠️ Could not extract timestamp from build UI URL: $BUILD_UI_URL"
                FALLBACK_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)
                echo "BUILD_STARTED_TIMESTAMP=$FALLBACK_TIMESTAMP" >> $GITHUB_ENV
                echo "build_started_timestamp=$FALLBACK_TIMESTAMP" >> $GITHUB_OUTPUT
              fi
            else
              echo "⚠️ Could not extract build UI URL from JFrog CLI output"
              FALLBACK_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)
              echo "BUILD_STARTED_TIMESTAMP=$FALLBACK_TIMESTAMP" >> $GITHUB_ENV
              echo "build_started_timestamp=$FALLBACK_TIMESTAMP" >> $GITHUB_OUTPUT
            fi
            echo "✅ Build info published successfully"
          else
            echo "BUILD_INFO_PUBLISH_STATUS=FAILED" >> $GITHUB_ENV
            echo "❌ Failed to publish build info" >&2
            exit 1
          fi

  create-promote:
    name: "Create Application Version & Promote (Conditional)"
    runs-on: ubuntu-latest
    needs: [analyze-commit, build-test-publish]
    if: needs.analyze-commit.outputs.create_app_version == 'true' && needs.build-test-publish.result == 'success'
    
    permissions:
      contents: read
      id-token: write

    env:
      BUILD_NAME: "bookverse-web_CI_create-promote"
      BUILD_NUMBER: ${{ needs.build-test-publish.outputs.build_number }}
      SERVICE_NAME: "web"
      APPLICATION_KEY: "bookverse-web"
      APP_VERSION: ${{ needs.build-test-publish.outputs.app_version }}
      BUILD_STARTED_TIMESTAMP: ${{ needs.build-test-publish.outputs.build_started_timestamp }}

    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Setup] JFrog CLI"
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        with:
          version: latest
        env:
          JFROG_CLI_BUILD_NAME: ${{ needs.build-test-publish.outputs.build_name }}
          JFROG_CLI_BUILD_NUMBER: ${{ env.BUILD_NUMBER }}
          JFROG_CLI_BUILD_PROJECT: ${{ vars.PROJECT_KEY }}

      - name: "[Info] Promotion Information"
        run: |
          echo "🚀 CI Pipeline: Promote Phase"
          echo "📋 Commit Analysis Result: ${{ needs.analyze-commit.outputs.commit_type }}"
          echo "💡 Decision: ${{ needs.analyze-commit.outputs.decision_reason }}"
          echo "🎯 Creating AppTrust Application Version"
          echo "👤 Triggered by: ${{ github.actor }}"
          echo "🕐 Timestamp: $(date -u)"

      - name: "[Auth] Exchange OIDC and persist JF access token"
        id: exchange-oidc
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          PROJECT: ${{ vars.PROJECT_KEY }}
          PROVIDER_NAME: bookverse-web-github
        run: |
          set -euo pipefail
          # Ensure jq
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
          # 1) Get GitHub OIDC ID token (audience -> JFrog URL)
          if [[ -z "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" || -z "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" ]]; then
            echo "❌ Missing GitHub OIDC request env vars" >&2; exit 1; fi
          GH_ID_TOKEN=$(curl -sS -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" \
            "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${JF_URL}" | jq -r .value)
          if [[ -z "$GH_ID_TOKEN" || "$GH_ID_TOKEN" == "null" ]]; then echo "❌ Failed to fetch GitHub ID token" >&2; exit 1; fi
          # 2) Exchange at JFrog Access for access token
          PAYLOAD=$(jq -n --arg jwt "$GH_ID_TOKEN" \
            '{grant_type: "urn:ietf:params:oauth:grant-type:token-exchange", subject_token: $jwt, subject_token_type: "urn:ietf:params:oauth:token-type:id_token", provider_name: env.PROVIDER_NAME}')
          JF_ACCESS_TOKEN=$(curl -sS -X POST "${JF_URL}/access/api/v1/oidc/token" \
            -H "Content-Type: application/json" -d "$PAYLOAD" | jq -r .access_token)
          if [[ -z "$JF_ACCESS_TOKEN" || "$JF_ACCESS_TOKEN" == "null" ]]; then echo "❌ Failed to exchange OIDC token" >&2; exit 1; fi
          # 3) Persist for subsequent steps
          echo "JF_ACCESS_TOKEN=$JF_ACCESS_TOKEN" >> $GITHUB_ENV
          echo "token=$JF_ACCESS_TOKEN" >> $GITHUB_OUTPUT
          echo "✅ JFrog access token obtained and persisted"

      - name: "[Setup] Install Python dependencies"
        run: |
          pip install --user PyYAML
          echo "✅ Python dependencies installed"

      - name: "[Setup] Determine SemVer"
        id: determine-semver
        run: |
          SERVICE_NAME=${SERVICE_NAME:-$(echo ${{ github.event.repository.name }} | sed 's/bookverse-//')}
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          
          # Use the persisted JF_ACCESS_TOKEN from the auth step
          if [[ -z "${JF_ACCESS_TOKEN:-}" ]]; then
            echo "❌ Missing JF_ACCESS_TOKEN. Ensure OIDC exchange step succeeded." >&2
            exit 1
          fi
          
          echo "✅ Using persisted JFrog access token for semver determination"
          
          # Use the unified semver determination script
          chmod +x ./scripts/determine-semver.sh
          SEMVER_OUTPUT=$(./scripts/determine-semver.sh \
            --application-key "$APPLICATION_KEY" \
            --version-map "./config/version-map.yaml" \
            --jfrog-url "${{ vars.JFROG_URL }}" \
            --jfrog-token "$JF_ACCESS_TOKEN" \
            --project-key "${{ vars.PROJECT_KEY }}" \
            --packages "$SERVICE_NAME" \
            --verbose)
          
          # Extract APP_VERSION from the Python script's JSON output
          APP_VERSION=$(echo "$SEMVER_OUTPUT" | grep '{"application_key"' | jq -r '.app_version')
          if [[ -z "$APP_VERSION" || "$APP_VERSION" == "null" ]]; then
            echo "❌ Failed to extract APP_VERSION from semver output" >&2
            exit 1
          fi
          
          echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT
          echo "✅ Determined APP_VERSION: $APP_VERSION"

      - name: "[Create] Application Version"
        run: |
          set -euo pipefail
          echo "🚀 Creating AppTrust Application Version"
          echo "📦 Application: $APPLICATION_KEY"
          echo "🔢 Version: $APP_VERSION"
          echo "🏗️ Build: $BUILD_NAME"
          echo "⏰ Build Started: $BUILD_STARTED_TIMESTAMP"
          
          # Determine application version tag (same as old working web UI)
          TAG_OPTIONS=(
            "release"
            "hotfix"
            "feature"
            "bugfix"
            "enhancement"
            "security"
            "performance"
            "refactor"
            "experimental"
            "maintenance"
            "integration"
            "documentation"
            "stable"
            "beta"
          )
          TAG_INDEX=$((${GITHUB_RUN_NUMBER:-0} % ${#TAG_OPTIONS[@]}))
          APP_TAG="${TAG_OPTIONS[$TAG_INDEX]}"
          echo "🏷️ Application Version Tag (demo simulation): $APP_TAG"
          
          # Create application version payload with build sources (same format as old working web UI)
          BUILD_INFO_REPO="bookverse-build-info"
          if [[ -n "$BUILD_STARTED_TIMESTAMP" && "$BUILD_STARTED_TIMESTAMP" != "null" ]]; then
            APP_VERSION_PAYLOAD=$(jq -n \
              --arg version "$APP_VERSION" \
              --arg tag "$APP_TAG" \
              --arg build_name "$BUILD_NAME" \
              --arg build_number "${{ needs.build-test-publish.outputs.build_number }}" \
              --arg build_info_repo "$BUILD_INFO_REPO" \
              --arg build_started "$BUILD_STARTED_TIMESTAMP" \
              '{
                version: $version,
                tag: $tag,
                sources: {
                  builds: [{
                    name: $build_name,
                    number: $build_number,
                    repository_key: $build_info_repo,
                    include_dependencies: false,
                    started: $build_started
                  }]
                }
              }')
          else
            APP_VERSION_PAYLOAD=$(jq -n \
              --arg version "$APP_VERSION" \
              --arg tag "$APP_TAG" \
              --arg build_name "$BUILD_NAME" \
              --arg build_number "${{ needs.build-test-publish.outputs.build_number }}" \
              --arg build_info_repo "$BUILD_INFO_REPO" \
              '{
                version: $version,
                tag: $tag,
                sources: {
                  builds: [{
                    name: $build_name,
                    number: $build_number,
                    repository_key: $build_info_repo,
                    include_dependencies: false
                  }]
                }
              }')
          fi
          
          echo "📤 Payload: $APP_VERSION_PAYLOAD"
          
          # Create application version via AppTrust API
          RESP_BODY=$(mktemp)
          HTTP_STATUS=$(curl -sS -L -o "$RESP_BODY" -w "%{http_code}" -X POST \
            "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions?async=false" \
            -H "Authorization: Bearer $JF_ACCESS_TOKEN" \
            -H "Content-Type: application/json" \
            -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" \
            -d "$APP_VERSION_PAYLOAD" \
            --fail-with-body )
          echo "🔢 HTTP Status: $HTTP_STATUS"
          echo "📨 Response Body:"; cat "$RESP_BODY" || true; echo
          if [ "$HTTP_STATUS" -ge 400 ]; then echo "❌ AppTrust API failed with $HTTP_STATUS"; exit 1; fi
          rm -f "$RESP_BODY"
          
          echo "✅ AppTrust Application Version created successfully"

      - name: "[Auto-Promote] Through Stages"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          echo "📈 Starting automatic promotion for ${{ env.APP_VERSION }}"
          
          # Set up promotion environment variables
          export JFROG_URL="${{ vars.JFROG_URL }}"
          export PROJECT_KEY="${{ vars.PROJECT_KEY }}"
          export APPLICATION_KEY="$APPLICATION_KEY"
          export APP_VERSION="${{ env.APP_VERSION }}"
          
          # Get the OIDC token from the previous step's output
          OIDC_TOKEN="${{ steps.exchange-oidc.outputs.token }}"
          if [[ -z "$OIDC_TOKEN" ]]; then
            echo "❌ Failed to get OIDC token from exchange step" >&2
            exit 1
          fi
          export APPTRUST_ACCESS_TOKEN="$OIDC_TOKEN"
          echo "✅ APPTRUST_ACCESS_TOKEN set for promotion library"
          
          # Source the promotion library
          source .github/scripts/promote_lib.sh
          
          # Set up lifecycle stages (demo-optimized: promote directly to PROD)
          export STAGES_STR="DEV QA STAGING PROD"
          export FINAL_STAGE="PROD"
          export ALLOW_RELEASE=true
          
          echo "🎯 Demo Mode: Auto-promoting through all stages to PROD"
          echo "📝 Production Note: Real systems would have approval gates and gradual rollout"
          
          # Fetch current status
          fetch_summary
          echo "📊 Current stage: ${CURRENT_STAGE:-UNASSIGNED}"
          
          # Promote through each stage automatically
          MAX_PROMOTIONS=4  # Safety limit
          PROMOTION_COUNT=0
          
          while [[ $PROMOTION_COUNT -lt $MAX_PROMOTIONS ]]; do
            fetch_summary
            CURRENT_DISPLAY=$(display_stage_for "${CURRENT_STAGE:-}")
            
            echo "🔄 Promotion step $((PROMOTION_COUNT + 1)): Currently at $CURRENT_DISPLAY"
            
            if [[ "$CURRENT_DISPLAY" == "PROD" ]]; then
              echo "🎉 Already at PROD - promotion complete!"
              break
            fi
            
            # Perform one promotion step
            if advance_one_step; then
              echo "✅ Promotion step $((PROMOTION_COUNT + 1)) successful"
              PROMOTION_COUNT=$((PROMOTION_COUNT + 1))
              
              # Brief pause between promotions for demo visibility
              sleep 2
            else
              echo "❌ Promotion step $((PROMOTION_COUNT + 1)) failed"
              exit 1
            fi
          done
          
          # Final status check
          fetch_summary
          FINAL_DISPLAY=$(display_stage_for "${CURRENT_STAGE:-}")
          echo "🏁 Final promotion status: $FINAL_DISPLAY"
          
          if [[ "$FINAL_DISPLAY" == "PROD" ]]; then
            echo "🎉 Successfully promoted $APP_VERSION to PROD!"
            echo "📊 Promotion completed in $PROMOTION_COUNT steps"
          else
            echo "⚠️ Promotion did not reach PROD (stopped at $FINAL_DISPLAY)"
            exit 1
          fi