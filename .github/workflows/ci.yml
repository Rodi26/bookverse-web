name: CI

# DEMO-READY: Automatic triggers enabled for full CI/CD pipeline demonstration
# PRODUCTION NOTE: Real systems would have additional branch protection and approval gates
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for manual CI trigger'
        required: false
        default: 'Manual testing'
        type: string
      force_app_version:
        description: 'Force application version creation (override commit filter)'
        required: false
        default: true
        type: boolean

jobs:
  analyze-commit:
    name: "Demo: Analyze Commit (Shared Script)"
    runs-on: ubuntu-latest
    outputs:
      create_app_version: ${{ steps.demo-filter.outputs.create_app_version }}
      decision_reason: ${{ steps.demo-filter.outputs.decision_reason }}
      commit_type: ${{ steps.demo-filter.outputs.commit_type }}
    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: "[Setup] Checkout bookverse-infra for shared scripts"
        uses: actions/checkout@v4
        with:
          repository: yonatanp-jfrog/bookverse-infra
          path: bookverse-infra
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: "[Demo] Commit Analysis (Shared Script - Web Adapted)"
        id: demo-filter
        env:
          GITHUB_EVENT_INPUTS_FORCE_APP_VERSION: ${{ inputs.force_app_version }}
        run: |
          echo "ðŸŽ¯ WEB SERVICE: Analyzing commit using shared bookverse-devops script"
          echo "ðŸ“ Commit: ${GITHUB_SHA:0:8}"
          echo "ðŸ’¬ Message: $(git log -1 --pretty=%B)"
          echo "ðŸ“ Changed files: $(git diff --name-only HEAD~1 | wc -l) files"
          echo "ðŸŒ Frontend note: Web services create application versions for UI releases"
          echo ""
          
          # Use shared analyze-commit script from bookverse-infra
          chmod +x bookverse-infra/libraries/bookverse-devops/scripts/analyze-commit.sh
          bookverse-infra/libraries/bookverse-devops/scripts/analyze-commit.sh

  build-test-publish:
    name: "Build & Test (Always Runs)"
    needs: analyze-commit
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    permissions:
      contents: read
      id-token: write
    outputs:
      build_name: ${{ steps.set-build-info.outputs.build_name }}
      build_started_timestamp: ${{ steps.publish-build-info.outputs.build_started_timestamp }}
      build_number: ${{ steps.set-build-info.outputs.build_number }}
      app_version: ${{ steps.set-app-version.outputs.app_version }}
      jf_oidc_token: ${{ steps.exchange-oidc.outputs.token }}

    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Setup] Checkout bookverse-infra for shared scripts"
        uses: actions/checkout@v4
        with:
          repository: yonatanp-jfrog/bookverse-infra
          path: bookverse-infra
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: "[Info] Trigger Information"
        run: |
          echo "ðŸš€ CI Pipeline: Build & Test Phase"
          echo "ðŸ“‹ Commit Analysis Result: ${{ needs.analyze-commit.outputs.commit_type }}"
          echo "ðŸ’¡ Decision: ${{ needs.analyze-commit.outputs.decision_reason }}"
          echo "ðŸŽ¯ Create App Version: ${{ needs.analyze-commit.outputs.create_app_version }}"
          echo "ðŸ‘¤ Triggered by: ${{ github.actor }}"
          echo "ðŸ• Timestamp: $(date -u)"

      - name: "[Setup] Build Info"
        id: set-build-info
        run: |
          BUILD_NAME="${{ github.event.repository.name }}_${{ github.workflow }}_${{ github.job }}"
          BUILD_NUMBER="${{ github.run_number }}-${{ github.run_attempt }}"
          echo "BUILD_NAME=$BUILD_NAME" >> $GITHUB_ENV
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          echo "build_name=$BUILD_NAME" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "SERVICE_NAME=web" >> $GITHUB_ENV
          echo "APPLICATION_KEY=bookverse-web" >> $GITHUB_ENV

      - name: "[Setup] JFrog CLI"
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        with:
          version: latest
          oidc-provider-name: bookverse-web-github
          oidc-audience: ${{ vars.JFROG_URL }}
          disable-job-summary: true
          disable-auto-build-publish: true
          disable-auto-evidence-collection: false
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
          JFROG_CLI_BUILD_NAME: ${{ env.BUILD_NAME }}
          JFROG_CLI_BUILD_NUMBER: ${{ env.BUILD_NUMBER }}
          JFROG_CLI_BUILD_PROJECT: ${{ vars.PROJECT_KEY }}
          
      - name: "[Setup] Verify JFrog Authentication"
        run: |
          echo "ðŸ” Verifying JFrog CLI authentication and connectivity..."
          jf c show
          jf rt ping

      - name: "[Auth] OIDC Token Exchange (bookverse-devops shared script)"
        id: exchange-oidc
        run: |
          echo "ðŸ” Using bookverse-devops shared OIDC exchange script for web service"
          # Use shared script to eliminate ~40 lines of duplicate OIDC logic
          bookverse-infra/libraries/bookverse-devops/scripts/exchange-oidc-token.sh \
            --service-name "web" \
            --provider-name "bookverse-web-github" \
            --jfrog-url "${{ vars.JFROG_URL }}" \
            --docker-registry "${{ vars.DOCKER_REGISTRY }}" \
            --verbose
          echo "âœ… OIDC token exchange completed using shared bookverse-devops script"

      - name: "[Setup] Determine SemVer"
        id: set-app-version
        run: |
          set -euo pipefail
          SERVICE_NAME=${SERVICE_NAME:-$(echo ${{ github.event.repository.name }} | sed 's/bookverse-//')}
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          
          # Use the shared semver determination script from bookverse-devops
          chmod +x bookverse-infra/libraries/bookverse-devops/scripts/determine-semver.sh
          SEMVER_OUTPUT=$(bookverse-infra/libraries/bookverse-devops/scripts/determine-semver.sh \
            --application-key "$APPLICATION_KEY" \
            --version-map "./config/version-map.yaml" \
            --jfrog-url "${{ vars.JFROG_URL }}" \
            --jfrog-token "$JF_OIDC_TOKEN" \
            --project-key "${{ vars.PROJECT_KEY }}" \
            --packages "web,web-assets" \
            --verbose)
          
          # Extract APP_VERSION and package versions from the Python script's JSON output
          JSON_LINE=$(echo "$SEMVER_OUTPUT" | grep '{"application_key"')
          APP_VERSION=$(echo "$JSON_LINE" | jq -r '.app_version')
          WEB_ASSETS_VERSION=$(echo "$JSON_LINE" | jq -r '.package_tags."web-assets" // empty')
          
          if [[ -z "$APP_VERSION" || "$APP_VERSION" == "null" ]]; then
            echo "âŒ Failed to extract APP_VERSION from semver output" >&2
            exit 1
          fi
          if [[ -z "$WEB_ASSETS_VERSION" ]]; then
            echo "âŒ Failed to determine WEB_ASSETS_VERSION from semver script" >&2
            exit 1
          fi
          
          echo "WEB_ASSETS_VERSION=$WEB_ASSETS_VERSION" >> $GITHUB_ENV
          echo "ðŸ“¦ Package versions determined:"
          echo "  ðŸŒ web-assets (Generic): $WEB_ASSETS_VERSION"
          echo "  ðŸ·ï¸ Application: $APP_VERSION"
          echo "  ðŸ”¢ Build Number (for build info): $BUILD_NUMBER"
          
          # Set IMAGE_TAG to the Docker package tag
          DOCKER_TAG_VAR="DOCKER_TAG_$(echo "$SERVICE_NAME" | tr '[:lower:]' '[:upper:]' | tr '-' '_')"
          if [[ -n "${!DOCKER_TAG_VAR:-}" ]]; then
            IMAGE_TAG="${!DOCKER_TAG_VAR}"
          else
            IMAGE_TAG="$BUILD_NUMBER"
          fi
          
          # Update IMAGE_NAME with the determined tag
          REGISTRY_URL="${{ vars.DOCKER_REGISTRY }}"
          REPO_KEY="${{ vars.PROJECT_KEY }}-$SERVICE_NAME-internal-docker-nonprod-local"
          IMAGE_NAME="$REGISTRY_URL/$REPO_KEY/$SERVICE_NAME:$IMAGE_TAG"
          
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT
          echo "APPLICATION_KEY=$APPLICATION_KEY" >> $GITHUB_ENV

      - name: "[Setup] Node"
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: "[Build] Install dependencies"
        run: |
          npm ci --no-audit --fund=false

      - name: "[Build] Build web assets"
        run: |
          npm run build --if-present

      - name: "[Build] Generic Artifact - Web Assets"
        run: |
          set -euo pipefail
          SERVICE_NAME=${SERVICE_NAME:-$(echo ${{ github.event.repository.name }} | sed 's/bookverse-//')}
          
          # Use web-assets package version from semver determination step
          echo "Using web-assets package version: $WEB_ASSETS_VERSION"
          
          # Create web assets package from dist/ folder
          echo "ðŸ“¦ Creating web-assets.tar.gz package from dist/ folder"
          
          # Create tar.gz package (following recommendations service pattern)
          # Create tar outside dist directory to avoid "file changed as we read it" error
          tar -czf "web-assets-$WEB_ASSETS_VERSION.tar.gz" -C dist .
          
          # Upload packaged artifact to generic repository
          GENERIC_REPO="${{ vars.PROJECT_KEY }}-$SERVICE_NAME-internal-generic-nonprod-local"
          jf rt upload "web-assets-$WEB_ASSETS_VERSION.tar.gz" "$GENERIC_REPO/$SERVICE_NAME/assets/$WEB_ASSETS_VERSION/web-assets-$WEB_ASSETS_VERSION.tar.gz" \
            --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER" --project "${{ vars.PROJECT_KEY }}"
          echo "âœ… Web assets package uploaded with version $WEB_ASSETS_VERSION"

      - name: "[Evidence] Web Assets Package"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          # Source the evidence library
          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          
          # Set package-specific environment variables  
          export PACKAGE_NAME="web-assets-$WEB_ASSETS_VERSION.tar.gz"
          export PACKAGE_VERSION="$WEB_ASSETS_VERSION"
          
          # Attach generic package evidence
          # Evidence: Config Bundle Verification (static assets validation and integrity)
          attach_generic_package_evidence "$PACKAGE_NAME" "$PACKAGE_VERSION"
          
          echo "âœ… Web assets package evidence attached: config-bundle"

      - name: "[Build] Docker image"
        run: |
          set -euo pipefail
          # Use JFrog CLI to authenticate pushes without requiring docker login
          SERVER_ID="${SETUP_JFROG_CLI_SERVER_IDS:-setup-jfrog-cli-server}"
          jf c use "$SERVER_ID" || true
          # Ensure project header is sent for OIDC-based commands like `jf docker`
          export JF_PROJECT="${{ vars.PROJECT_KEY }}"
          # Also set build project explicitly for JFrog CLI commands
          export JFROG_CLI_BUILD_PROJECT="${{ vars.PROJECT_KEY }}"

          # Using OIDC-based server configuration from setup action; no admin token required
          # Use precomputed IMAGE_TAG/IMAGE_NAME from set-app-version step to avoid drift
          echo "Using precomputed image tag: $IMAGE_TAG"
          echo "Using precomputed image name: $IMAGE_NAME"

          # Build and push (plain docker) using subdomain host; then create build-info
          jf docker build --pull -t "$IMAGE_NAME" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER" .
          docker push "$IMAGE_NAME"

          # Build-info will be published in a later step via bag/bce/bp
          echo "DOCKER_BUILD_PUSH_STATUS=SUCCESS" >> $GITHUB_ENV
          echo "âœ… Built and pushed Docker image (OIDC docker push + build-info)"

      - name: "[Evidence] Docker Package"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          # Source the evidence library
          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          
          # Set package-specific environment variables
          export PACKAGE_NAME="web"
          export PACKAGE_VERSION="$IMAGE_TAG"
          
          # Attach Docker package evidence
          # Evidence: PyTest Results (unit test coverage) + SAST Scan (static security analysis)
          attach_docker_package_evidence "$PACKAGE_NAME" "$PACKAGE_VERSION"
          
          echo "âœ… Web Docker image package evidence attached: pytest-results, sast-scan"

      - name: "[Build Info] Publish"
        id: publish-build-info
        run: |
          # Associate the pushed Docker image with the build-info before publishing
          REPO_KEY="${{ vars.PROJECT_KEY }}-$SERVICE_NAME-internal-docker-nonprod-local"
          echo "ðŸ”— Adding docker image to build-info: image=$IMAGE_NAME repo=$REPO_KEY"
          # Resolve pushed image digest and write in required format: image:tag@sha256:...
          DIGEST=$(docker inspect "$IMAGE_NAME" --format='{{index .RepoDigests 0}}' 2>/dev/null | awk -F@ '{print $2}')
          if [[ -z "$DIGEST" || "$DIGEST" == "<no value>" ]]; then
            docker pull "$IMAGE_NAME" >/dev/null 2>&1 || true
            DIGEST=$(docker inspect "$IMAGE_NAME" --format='{{index .RepoDigests 0}}' 2>/dev/null | awk -F@ '{print $2}')
          fi
          if [[ -z "$DIGEST" || "$DIGEST" == "<no value>" ]]; then
            echo "âŒ Could not resolve image digest for $IMAGE_NAME" >&2; exit 1
          fi
          echo "${IMAGE_NAME%@*}@${DIGEST}" > images.txt
          jf rt build-docker-create "$REPO_KEY" \
            --image-file images.txt \
            --build-name "$BUILD_NAME" \
            --build-number "$BUILD_NUMBER" \
            --project "${{ vars.PROJECT_KEY }}"
          
          jf rt bag --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"
          jf rt bce --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"
          if BUILD_PUBLISH_RESULT=$(jf rt bp --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"); then
            echo "BUILD_INFO_PUBLISH_STATUS=SUCCESS" >> $GITHUB_ENV
            
            # Extract timestamp from build publish result (optimized - no extra API call)
            # Parse the UI URL from JFrog CLI log output instead of non-existent JSON field
            BUILD_UI_URL=$(echo "$BUILD_PUBLISH_RESULT" | grep -o 'https://[^[:space:]]*builds/[^[:space:]]*' | head -1 || echo "")
            if [[ -n "$BUILD_UI_URL" ]]; then
              # Extract epoch milliseconds from UI URL: .../builds/NAME/NUMBER/TIMESTAMP/published
              EPOCH_MS=$(echo "$BUILD_UI_URL" | sed -n 's|.*/builds/[^/]*/[^/]*/\([0-9]*\)/published.*|\1|p')
              
              if [[ -n "$EPOCH_MS" && "$EPOCH_MS" =~ ^[0-9]+$ ]]; then
                # Convert to JFrog's exact timestamp format: YYYY-MM-DDTHH:MM:SS.mmm+0000
                EPOCH_SEC=$((EPOCH_MS / 1000))
                MILLISECS=$((EPOCH_MS % 1000))
                BUILD_STARTED_TIMESTAMP=$(date -u -r "$EPOCH_SEC" "+%Y-%m-%dT%H:%M:%S" 2>/dev/null || date -u -d "@$EPOCH_SEC" "+%Y-%m-%dT%H:%M:%S")
                BUILD_STARTED_TIMESTAMP="${BUILD_STARTED_TIMESTAMP}.$(printf "%03d" $MILLISECS)+0000"
                
                echo "BUILD_STARTED_TIMESTAMP=$BUILD_STARTED_TIMESTAMP" >> $GITHUB_ENV
                echo "build_started_timestamp=$BUILD_STARTED_TIMESTAMP" >> $GITHUB_OUTPUT
                echo "âœ… Extracted timestamp from build publish result: $BUILD_STARTED_TIMESTAMP"
              else
                echo "âš ï¸ Could not extract epoch milliseconds from build UI URL: $BUILD_UI_URL"
                FALLBACK_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)
                echo "BUILD_STARTED_TIMESTAMP=$FALLBACK_TIMESTAMP" >> $GITHUB_ENV
                echo "build_started_timestamp=$FALLBACK_TIMESTAMP" >> $GITHUB_OUTPUT
              fi
            else
              echo "âš ï¸ Could not extract build UI URL from JFrog CLI output"
              FALLBACK_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)
              echo "BUILD_STARTED_TIMESTAMP=$FALLBACK_TIMESTAMP" >> $GITHUB_ENV
              echo "build_started_timestamp=$FALLBACK_TIMESTAMP" >> $GITHUB_OUTPUT
            fi
            echo "âœ… Build info published successfully"
          else
            echo "BUILD_INFO_PUBLISH_STATUS=FAILED" >> $GITHUB_ENV
            echo "âŒ Failed to publish build info" >&2
            exit 1
          fi

      - name: "[Evidence] Build Evidence"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          echo "ðŸ—ï¸ Generating evidence for build-info"
          
          # Source the evidence library
          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          
          # Build evidence uses auto-detected environment variables
          
          # Attach build evidence
          # Evidence: FOSSA License Scan (dependency license compliance) + SonarQube Quality Gate (code quality analysis)
          attach_build_evidence
          
          echo "âœ… Build evidence attached: fossa-license-scan, sonar-quality-gate"

  create-promote:
    name: "Create Application Version & Promote (Conditional)"
    runs-on: ubuntu-latest
    needs: [analyze-commit, build-test-publish]
    if: needs.analyze-commit.outputs.create_app_version == 'true' && needs.build-test-publish.result == 'success'
    
    permissions:
      contents: read
      id-token: write

    env:
      BUILD_NAME: "bookverse-web_CI_create-promote"
      BUILD_NUMBER: ${{ needs.build-test-publish.outputs.build_number }}
      SERVICE_NAME: "web"
      APPLICATION_KEY: "bookverse-web"
      APP_VERSION: ${{ needs.build-test-publish.outputs.app_version }}
      BUILD_STARTED_TIMESTAMP: ${{ needs.build-test-publish.outputs.build_started_timestamp }}
      EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
      JFROG_URL: ${{ vars.JFROG_URL }}
      JF_URL: ${{ vars.JFROG_URL }}
      PROJECT_KEY: ${{ vars.PROJECT_KEY }}
      STAGES_STR: "DEV QA STAGING PROD"
      FINAL_STAGE: "PROD"
      ALLOW_RELEASE: "true"

    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Setup] Checkout bookverse-infra for shared scripts"
        uses: actions/checkout@v4
        with:
          repository: yonatanp-jfrog/bookverse-infra
          path: bookverse-infra
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: "[Setup] JFrog CLI"
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        with:
          version: latest
          oidc-provider-name: bookverse-web-github
          oidc-audience: ${{ vars.JFROG_URL }}
          disable-job-summary: true
          disable-auto-build-publish: true
          disable-auto-evidence-collection: false
        env:
          JFROG_CLI_BUILD_NAME: ${{ needs.build-test-publish.outputs.build_name }}
          JFROG_CLI_BUILD_NUMBER: ${{ env.BUILD_NUMBER }}
          JFROG_CLI_BUILD_PROJECT: ${{ vars.PROJECT_KEY }}

      - name: "[Info] Promotion Information"
        run: |
          echo "ðŸš€ CI Pipeline: Promote Phase"
          echo "ðŸ“‹ Commit Analysis Result: ${{ needs.analyze-commit.outputs.commit_type }}"
          echo "ðŸ’¡ Decision: ${{ needs.analyze-commit.outputs.decision_reason }}"
          echo "ðŸŽ¯ Creating AppTrust Application Version"
          echo "ðŸ‘¤ Triggered by: ${{ github.actor }}"
          echo "ðŸ• Timestamp: $(date -u)"

      - name: "[Auth] OIDC Token Exchange (bookverse-devops shared script)"
        id: exchange-oidc
        run: |
          echo "ðŸ” Using bookverse-devops shared OIDC exchange script for web service promotion"
          # Use shared script to eliminate ~25 lines of duplicate OIDC logic
          bookverse-infra/libraries/bookverse-devops/scripts/exchange-oidc-token.sh \
            --service-name "web" \
            --provider-name "bookverse-web-github" \
            --jfrog-url "${{ vars.JFROG_URL }}" \
            --docker-registry "${{ vars.DOCKER_REGISTRY }}" \
            --verbose
          echo "âœ… OIDC token exchange completed using shared bookverse-devops script"

      - name: "[Setup] Install Python dependencies"
        run: |
          pip install --user PyYAML
          echo "âœ… Python dependencies installed"

      - name: "[Setup] Determine SemVer"
        id: determine-semver
        run: |
          SERVICE_NAME=${SERVICE_NAME:-$(echo ${{ github.event.repository.name }} | sed 's/bookverse-//')}
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          
          # Use the persisted JF_OIDC_TOKEN from the auth step
          if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
            echo "âŒ Missing JF_OIDC_TOKEN. Ensure OIDC exchange step succeeded." >&2
            exit 1
          fi
          
          echo "âœ… Using persisted JFrog access token for semver determination"
          
          # Use the shared semver determination script from bookverse-devops
          chmod +x bookverse-infra/libraries/bookverse-devops/scripts/determine-semver.sh
          SEMVER_OUTPUT=$(bookverse-infra/libraries/bookverse-devops/scripts/determine-semver.sh \
            --application-key "$APPLICATION_KEY" \
            --version-map "./config/version-map.yaml" \
            --jfrog-url "${{ vars.JFROG_URL }}" \
            --jfrog-token "$JF_OIDC_TOKEN" \
            --project-key "${{ vars.PROJECT_KEY }}" \
            --packages "web,web-assets" \
            --verbose)
          
          # Extract APP_VERSION from the Python script's JSON output
          APP_VERSION=$(echo "$SEMVER_OUTPUT" | grep '{"application_key"' | jq -r '.app_version')
          if [[ -z "$APP_VERSION" || "$APP_VERSION" == "null" ]]; then
            echo "âŒ Failed to extract APP_VERSION from semver output" >&2
            exit 1
          fi
          
          echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT
          echo "âœ… Determined APP_VERSION: $APP_VERSION"

      - name: "[Create] Application Version"
        run: |
          echo "ðŸš€ Creating application version ${{ env.APP_VERSION }}"
          
          # Create application version using AppTrust API payload structure
          # Adapted from working inventory service pattern for web service
          BASE="${{ vars.JFROG_URL }}/apptrust/api/v1"
          APP_KEY="$APPLICATION_KEY"
          
          # Generate demo tag for web UI releases
          TAG_OPTIONS=(
            "release"
            "hotfix" 
            "feature"
            "bugfix"
            "enhancement"
            "security"
            "performance"
            "refactor"
            "experimental"
            "maintenance"
            "integration"
            "documentation"
            "stable"
            "beta"
          )
          TAG_INDEX=$((${GITHUB_RUN_NUMBER:-0} % ${#TAG_OPTIONS[@]}))
          APP_TAG="${TAG_OPTIONS[$TAG_INDEX]}"
          
          # Use the build name from the build-test-publish job where build info was published
          ACTUAL_BUILD_NAME="${{ needs.build-test-publish.outputs.build_name }}"
          
          # Create payload using string concatenation (adapted from inventory service)
          APP_VERSION_PAYLOAD='{"version":"'$APP_VERSION'","tag":"'$APP_TAG'","sources":{"builds":[{"name":"'$ACTUAL_BUILD_NAME'","number":"'$BUILD_NUMBER'","repository_key":"'${{ vars.PROJECT_KEY }}'-build-info","include_dependencies":false}]}}'
          
          echo "ðŸ“‹ Creating application version with payload:"
          echo "$APP_VERSION_PAYLOAD" | jq . || echo "$APP_VERSION_PAYLOAD"
          
          # Call AppTrust API using approach adapted from inventory service
          RESP_BODY=$(mktemp)
          HTTP_STATUS=$(curl -sS -L -o "$RESP_BODY" -w "%{http_code}" -X POST \
            "$BASE/applications/$APP_KEY/versions?async=false" \
            -H "Authorization: Bearer ${{ steps.exchange-oidc.outputs.token }}" \
            -H "Content-Type: application/json" \
            -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" \
            -d "$APP_VERSION_PAYLOAD" \
            --fail-with-body)
          
          echo "ðŸ”¢ HTTP Status: $HTTP_STATUS"
          echo "ðŸ“¨ Response Body:"
          cat "$RESP_BODY" | jq . 2>/dev/null || cat "$RESP_BODY"
          echo ""
          
          if [[ "$HTTP_STATUS" -ge 200 && "$HTTP_STATUS" -lt 300 ]]; then
            echo "âœ… Created application version $APP_VERSION"
          else
            echo "âš ï¸ Application version creation returned HTTP $HTTP_STATUS"
            # For demo purposes, continue even if version already exists
            if [[ "$HTTP_STATUS" == "409" ]]; then
              echo "ðŸ“ Version $APP_VERSION already exists, continuing with promotion..."
            else
              echo "âŒ Failed to create application version" >&2
              rm -f "$RESP_BODY"
              exit 1
            fi
          fi
          rm -f "$RESP_BODY"

      - name: "[Evidence] Application Version (UNASSIGNED)"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          # Source the evidence library
          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          
          # Application evidence uses auto-detected environment variables
          
          # Attach application evidence for UNASSIGNED stage
          # Evidence: SLSA Provenance (supply chain security) + Jira Release (release tracking and approval)
          attach_application_unassigned_evidence
          
          echo "âœ… Application version evidence attached: slsa-provenance, jira-release"

      - name: "[Promote & Evidence] DEV Stage"
        run: |
          echo "ðŸš€ Promoting to DEV stage and generating evidence"
          
           # Use the JF_OIDC_TOKEN from the OIDC exchange step
           if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
             echo "âŒ Missing JF_OIDC_TOKEN. Ensure OIDC exchange step succeeded." >&2
             exit 1
           fi
           echo "âœ… Using JF_OIDC_TOKEN for DEV promotion"
          
          # Source evidence library (includes promotion setup)
          export APPTRUST_ACCESS_TOKEN="$JF_OIDC_TOKEN"
          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          setup_promotion_environment
          
          # Promote to DEV
          if advance_one_step; then
            echo "âœ… Successfully promoted to DEV"
          else
            echo "âŒ Failed to promote to DEV"
            exit 1
          fi
          
          # Generate and attach DEV stage evidence
          # Evidence: Smoke Tests (basic health checks in DEV environment)
          attach_application_dev_evidence
          echo "âœ… DEV stage evidence attached: smoke-tests"

      - name: "[Promote & Evidence] QA Stage"
        run: |
          echo "ðŸš€ Promoting to QA stage and generating evidence"
          
          # Use the persisted JF_OIDC_TOKEN
          if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
            echo "âŒ Missing JF_OIDC_TOKEN. Ensure OIDC exchange step succeeded." >&2
            exit 1
          fi
          export APPTRUST_ACCESS_TOKEN="$JF_OIDC_TOKEN"
          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          setup_promotion_environment
          
          # Promote to QA
          if advance_one_step; then
            echo "âœ… Successfully promoted to QA"
          else
            echo "âŒ Failed to promote to QA"
            exit 1
          fi
          
          # Generate and attach QA stage evidence
          # Evidence: DAST Scan (dynamic security testing) + API Tests (integration testing)
          attach_application_qa_evidence
          echo "âœ… QA stage evidence attached: dast-scan, api-tests"

      - name: "[Promote & Evidence] STAGING Stage"
        run: |
          echo "ðŸš€ Promoting to STAGING stage and generating evidence"
          
          # Use the persisted JF_OIDC_TOKEN
          if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
            echo "âŒ Missing JF_OIDC_TOKEN. Ensure OIDC exchange step succeeded." >&2
            exit 1
          fi
          export APPTRUST_ACCESS_TOKEN="$JF_OIDC_TOKEN"
          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          setup_promotion_environment
          
          # Promote to STAGING
          if advance_one_step; then
            echo "âœ… Successfully promoted to STAGING"
          else
            echo "âŒ Failed to promote to STAGING"
            exit 1
          fi
          
          # Generate and attach STAGING stage evidence
          # Evidence: IaC Scan (infrastructure security) + Pentest (penetration testing) + Change Approval (management approval)
          attach_application_staging_evidence
          echo "âœ… STAGING stage evidence attached: iac-scan, pentest, change-approval"

      - name: "[Promote & Evidence] PROD Stage"
        run: |
          echo "ðŸš€ Promoting to PROD stage and generating evidence"
          
          # Use the persisted JF_OIDC_TOKEN
          if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
            echo "âŒ Missing JF_OIDC_TOKEN. Ensure OIDC exchange step succeeded." >&2
            exit 1
          fi
          export APPTRUST_ACCESS_TOKEN="$JF_OIDC_TOKEN"
          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          setup_promotion_environment
          
          # Promote to PROD (release)
          if advance_one_step; then
            echo "âœ… Successfully promoted to PROD"
          else
            echo "âŒ Failed to promote to PROD"
            exit 1
          fi

          # Generate and attach PROD stage evidence
          # Evidence: ArgoCD Deployment Verification (production deployment health and status)
          attach_application_prod_evidence
          echo "âœ… PROD stage evidence attached: deployment-verification"
          echo "ðŸŽ‰ SUCCESS: Application version $APP_VERSION promoted to PROD with all evidence attached!"

      - name: "ðŸ“Š Enhanced Build Summary (bookverse-devops pattern)"
        if: always()
        run: |
          echo "## ðŸš€ Web Service CI/CD Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow:** ${{ github.workflow }} | **Run:** ${{ github.run_number }}-${{ github.run_attempt }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** \`${GITHUB_SHA:0:8}\` | **Branch:** \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### ðŸ“¦ Artifacts Created" >> $GITHUB_STEP_SUMMARY
          echo "- **Docker Images:**" >> $GITHUB_STEP_SUMMARY
          echo "  - ðŸ³ web: \`${{ env.IMAGE_TAG || 'N/A' }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Generic Artifacts:**" >> $GITHUB_STEP_SUMMARY
          echo "  - ðŸŒ web-assets: \`v${{ env.WEB_ASSETS_VERSION || 'N/A' }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Evidence Artifacts:** âœ… Collected and uploaded" >> $GITHUB_STEP_SUMMARY
          echo "- **Build-Info:** âœ… Published with all artifacts" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### ðŸš€ Application Version" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** \`${{ env.APP_VERSION }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Lifecycle:** DEV â†’ QA â†’ STAGING â†’ PROD (Complete)" >> $GITHUB_STEP_SUMMARY
          echo "- **Evidence:** âœ… All stages have evidence attached" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.analyze-commit.outputs.create_app_version }}" == "true" ]]; then
            echo "### ðŸŽ‰ Deployment Ready" >> $GITHUB_STEP_SUMMARY
            echo "Application version \`${{ env.APP_VERSION }}\` is now available in **PROD**." >> $GITHUB_STEP_SUMMARY
          else
            echo "### ðŸ“¦ Build-Info Only" >> $GITHUB_STEP_SUMMARY
            echo "This commit created build-info artifacts only (no application version)." >> $GITHUB_STEP_SUMMARY
            echo "Use manual workflow dispatch with \`force_app_version=true\` to create an application version." >> $GITHUB_STEP_SUMMARY
          fi