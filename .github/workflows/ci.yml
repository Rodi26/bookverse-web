name: CI

# NOTE: Manual trigger only during development phase
# Will be changed to automatic triggers (push/PR) when demo is ready
on:
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for manual CI trigger'
        required: false
        default: 'Manual testing'
        type: string

jobs:
  build-test-publish:
    name: CI
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    permissions:
      contents: read
      id-token: write
    outputs:
      build_name: ${{ steps.set-build-info.outputs.build_name }}
      build_number: ${{ steps.set-build-info.outputs.build_number }}
      app_version: ${{ steps.set-app-version.outputs.app_version }}

    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Info] Manual trigger"
        run: |
          echo "üöÄ Manual CI trigger initiated"
          echo "üìù Reason: ${{ inputs.reason || 'Manual testing' }}"
          echo "üë§ Triggered by: ${{ github.actor }}"
          echo "üïê Timestamp: $(date -u)"

      - name: "[Setup] Build Info"
        id: set-build-info
        run: |
          BUILD_NAME="${{ github.event.repository.name }}_${{ github.workflow }}_${{ github.job }}"
          BUILD_NUMBER="${{ github.run_number }}-${{ github.run_attempt }}"
          echo "BUILD_NAME=$BUILD_NAME" >> $GITHUB_ENV
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          echo "build_name=$BUILD_NAME" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT

      - name: "[Setup] Build variables"
        run: |
          SERVICE_NAME=$(echo ${{ github.event.repository.name }} | sed 's/bookverse-//')
          IMAGE_TAG=$(echo $GITHUB_SHA | head -c7)
          REGISTRY_URL="${{ vars.DOCKER_REGISTRY }}"
          IMAGE_NAME="${REGISTRY_URL}/${{ vars.PROJECT_KEY }}-${SERVICE_NAME}-internal-docker-nonprod-local/${SERVICE_NAME}:${IMAGE_TAG}"
          DOCKER_REPO="${{ vars.PROJECT_KEY }}-${SERVICE_NAME}-internal-docker-nonprod-local"
          GENERIC_REPO="${{ vars.PROJECT_KEY }}-${SERVICE_NAME}-internal-generic-nonprod-local"

          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          echo "APPLICATION_KEY=$APPLICATION_KEY" >> $GITHUB_ENV
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "REGISTRY_URL=$REGISTRY_URL" >> $GITHUB_ENV
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV
          echo "DOCKER_REPO=$DOCKER_REPO" >> $GITHUB_ENV
          echo "GENERIC_REPO=$GENERIC_REPO" >> $GITHUB_ENV

      - name: "[Setup] JFrog CLI"
        # Temporary workaround: using forked action until upstream fix
        # uses: jfrog/setup-jfrog-cli@v4
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
          JFROG_CLI_BUILD_NAME: ${{ steps.set-build-info.outputs.build_name }}
          JFROG_CLI_BUILD_NUMBER: ${{ steps.set-build-info.outputs.build_number }}
        with:
          version: latest
          oidc-provider-name: bookverse-web-github
          disable-job-summary: false
          disable-auto-build-publish: true
          disable-auto-evidence-collection: false
          oidc-audience: ${{ vars.JFROG_URL }}

      - name: "[Setup] Verify JFrog Authentication"
        run: |
          echo "üîê Verifying JFrog CLI authentication and connectivity..."
          jf rt ping
          echo "‚úÖ JFrog authentication successful"

      - name: "[Auth] Exchange OIDC and persist JF access token"
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          PROJECT: ${{ vars.PROJECT_KEY }}
          PROVIDER_NAME: bookverse-web-github
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
          if [[ -z "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" || -z "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" ]]; then
            echo "‚ùå Missing GitHub OIDC request env vars" >&2; exit 1; fi
          GH_ID_TOKEN=$(curl -sS -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" \
            "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${JF_URL}" | jq -r .value)
          if [[ -z "$GH_ID_TOKEN" || "$GH_ID_TOKEN" == "null" ]]; then echo "‚ùå Failed to fetch GitHub ID token" >&2; exit 1; fi
          PAYLOAD=$(jq -n --arg jwt "$GH_ID_TOKEN" \
            --arg provider_name "$PROVIDER_NAME" \
            --arg project_key "$PROJECT" \
            --arg job_id "${{ github.job }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg repo "https://github.com/${{ github.repository }}" \
            --arg revision "${{ github.sha }}" \
            --arg branch "${{ github.ref_name }}" \
            '{
              grant_type:"urn:ietf:params:oauth:grant-type:token-exchange",
              subject_token_type:"urn:ietf:params:oauth:token-type:id_token",
              subject_token:$jwt,
              provider_name:$provider_name,
              project_key:$project_key,
              job_id:$job_id,
              run_id:$run_id,
              repo:$repo,
              revision:$revision,
              branch:$branch
            }')
          TOKEN=$(curl -sS -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "$JF_URL/access/api/v1/oidc/token" | jq -r .access_token)
          if [[ -z "$TOKEN" || "$TOKEN" == "null" ]]; then echo "‚ùå Failed to exchange OIDC token" >&2; exit 1; fi
          echo "JF_ACCESS_TOKEN=$TOKEN" >> $GITHUB_ENV

      - name: "[Setup] Install Python dependencies"
        run: |
          pip install PyYAML
          echo "‚úÖ Python dependencies installed"

      - name: "[Setup] Determine SemVer"
        id: set-app-version
        run: |
          set -euo pipefail
          SERVICE_NAME=${SERVICE_NAME:-$(echo ${{ github.event.repository.name }} | sed 's/bookverse-//')}
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          REGISTRY_URL=${REGISTRY_URL:-${{ vars.DOCKER_REGISTRY }}}
          REPO_KEY="${{ vars.PROJECT_KEY }}-$SERVICE_NAME-internal-docker-nonprod-local"
          
          # Use the unified semver determination script
          chmod +x ./scripts/determine-semver.sh
          SEMVER_OUTPUT=$(./scripts/determine-semver.sh \
            --application-key "$APPLICATION_KEY" \
            --version-map "./config/version-map.yaml" \
            --jfrog-url "${{ vars.JFROG_URL }}" \
            --jfrog-token "$JF_ACCESS_TOKEN" \
            --project-key "${{ vars.PROJECT_KEY }}" \
            --packages "web,web-assets.tar.gz" \
            --verbose)
          
          # Extract APP_VERSION from the Python script's JSON output
          APP_VERSION=$(echo "$SEMVER_OUTPUT" | grep '{"application_key"' | jq -r '.app_version')
          if [[ -z "$APP_VERSION" || "$APP_VERSION" == "null" ]]; then
            echo "‚ùå Failed to extract APP_VERSION from semver output" >&2
            exit 1
          fi          
          # Set IMAGE_TAG to the Docker package tag for 'web' package
          if [[ -n "${DOCKER_TAG_WEB:-}" ]]; then
            IMAGE_TAG="$DOCKER_TAG_WEB"
          else
            IMAGE_TAG="$BUILD_NUMBER"
          fi
          
          # Set WEB_ASSETS_TAG from the generic package
          if [[ -n "${DOCKER_TAG_WEB_ASSETS_TAR_GZ:-}" ]]; then
            WEB_ASSETS_TAG="$DOCKER_TAG_WEB_ASSETS_TAR_GZ"
          else
            WEB_ASSETS_TAG="$APP_VERSION"
          fi
          
          # Update environment variables
          IMAGE_NAME_PATH="$REGISTRY_URL/$REPO_KEY/$SERVICE_NAME:$IMAGE_TAG"
          IMAGE_NAME="$IMAGE_NAME_PATH"
          
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "WEB_ASSETS_TAG=$WEB_ASSETS_TAG" >> $GITHUB_ENV
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV
          echo "APPLICATION_KEY=$APPLICATION_KEY" >> $GITHUB_ENV
          
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "web_assets_tag=$WEB_ASSETS_TAG" >> $GITHUB_OUTPUT
          
          echo "üßÆ Final determined versions:"
          echo "  App Version: $APP_VERSION"
          echo "  Docker Image Tag: $IMAGE_TAG"
          echo "  Web Assets Tag: $WEB_ASSETS_TAG"

      - name: Set canonical Build Info env (redundant outputs avoided)
        run: |
          BUILD_NAME="${{ github.event.repository.name }}_${{ github.workflow }}_${{ github.job }}"
          echo "BUILD_NAME=$BUILD_NAME" >> $GITHUB_ENV
          echo "‚ÑπÔ∏è BUILD_NUMBER: $BUILD_NUMBER"

      

      - name: "[Setup] Node"
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: "[Build] Install deps"
        run: |
          npm ci --no-audit --fund=false

      - name: "[Build] Web assets"
        run: |
          npm run build --if-present

      - name: "[Artifacts] Web assets tar"
        run: |
          set -euo pipefail
          mkdir -p dist
          TAR_PATH="dist/web-assets-$WEB_ASSETS_TAG.tar.gz"
          if [ -d "dist" ]; then
            tar -czf "$TAR_PATH" dist || true
          else
            echo "No dist directory to package; creating empty placeholder"
            mkdir -p empty && tar -czf "$TAR_PATH" empty
          fi
          jf rt upload "$TAR_PATH" "$GENERIC_REPO/$SERVICE_NAME/assets/$WEB_ASSETS_TAG/" --flat=true --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER"
          echo "‚úÖ Uploaded web assets tarball to generic repo with version $WEB_ASSETS_TAG"

      - name: "[Build] Docker image"
        run: |
          set -euo pipefail
          # Use the IMAGE_TAG determined in the SemVer step
          jf docker build --pull -t "$IMAGE_NAME" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER" .
          # TEMP: Artifactory < 7.33.3 doesn't support 'jf docker push'.
          # Re-enable the original push line below once Artifactory is upgraded.
          # jf docker push "$IMAGE_NAME" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER"
          # Using deprecated fallback below: 'jf rt docker-push' (alias: 'jf rt dp').
          jf rt dp --project "${{ vars.PROJECT_KEY }}" "$IMAGE_NAME" "$DOCKER_REPO"
          echo "‚úÖ Built and pushed Docker image (with build-info)"

      - name: "[Build Info] Publish"
        run: |
          jf rt bag --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"
          jf rt bce --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"
          jf rt bp --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"

      # Evidence Plan: Build subject ‚Äì code-quality (UI)
      - name: "[Evidence] Prepare quality gate"
        run: |
          set -euo pipefail
          echo "üìÑ Preparing UI quality gate template"
          cat > quality-gate.template.md <<'EOF'
          # UI Quality Gate Report

          > ‚úÖ Status: PASSED

          The project meets UI quality requirements (lint/tests placeholder for demo).

          ---

          ## Gate Details

          * **Analysis Tool**: `ESLint/Jest (demo)`
          * **Result**: `PASSED`
          * **Checked At (UTC)**: `${NOW_TS}`
          EOF

      - name: "[Evidence] Attach quality gate"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          if ! command -v envsubst >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y gettext-base; fi
          NOW_TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          cat > quality-gate.json <<JSON
          {
            "qualityGate": {
              "tool": "ESLint/Jest (demo)",
              "status": "PASSED",
              "checkedAt": "${NOW_TS}"
            }
          }
          JSON
          export NOW_TS="${NOW_TS}"
          envsubst < quality-gate.template.md > quality-gate.md
          jf evd create-evidence \
            --predicate quality-gate.json \
            --markdown quality-gate.md \
            --predicate-type "https://sonarsource.com/evidence/quality-gate/v1" \
            --build-name "$BUILD_NAME" \
            --build-number "$BUILD_NUMBER" \
            --project "${{ vars.PROJECT_KEY }}" \
            --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" || echo "‚ö†Ô∏è UI quality gate evidence attachment failed"

      # Evidence Plan: Build subject ‚Äì license-compliance (FOSSA)
      - name: "[Evidence] Prepare license template"
        run: |
          set -euo pipefail
          echo "üìÑ Preparing license compliance template"
          cat > license-evidence.template.md <<'EOF'
          # üõ°Ô∏è FOSSA License Compliance Report

          > ‚úÖ Status: PASSED

          All software dependencies are in compliance with the project's license policies (demo placeholder).

          ---

          ## Scan Details

          * **Compliance Tool**: `FOSSA (demo)`
          * **Result**: `PASSED`
          * **Checked At (UTC)**: `${NOW_TS}`
          EOF

      - name: "[Evidence] Attach license compliance"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          if ! command -v envsubst >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y gettext-base; fi
          NOW_TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          cat > license-evidence.json <<JSON
          {
            "licenseScan": {
              "tool": "FOSSA (demo)",
              "status": "PASSED",
              "checkedAt": "${NOW_TS}"
            }
          }
          JSON
          export NOW_TS="${NOW_TS}"
          envsubst < license-evidence.template.md > license-evidence.md
          jf evd create-evidence \
            --predicate license-evidence.json \
            --markdown license-evidence.md \
            --predicate-type "https://fossa.com/evidence/license-scan/v2.1" \
            --build-name "$BUILD_NAME" \
            --build-number "$BUILD_NUMBER" \
            --project "${{ vars.PROJECT_KEY }}" \
            --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" || echo "‚ö†Ô∏è License compliance evidence attachment failed"

  create-application-version:
    name: Create Version
    needs: build-test-publish
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    permissions:
      contents: read
      id-token: write

    env:
      JFROG_CLI_SIGNING_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}

    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Setup] JFrog CLI"
        # Temporary workaround: using forked action until upstream fix
        # uses: jfrog/setup-jfrog-cli@v4
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
          JFROG_CLI_BUILD_NAME: ${{ github.event.repository.name }}_${{ github.workflow }}_${{ github.job }}
          JFROG_CLI_BUILD_NUMBER: ${{ github.run_number }}-${{ github.run_attempt }}
        with:
          version: latest
          oidc-provider-name: bookverse-web-github
          disable-job-summary: false
          disable-auto-build-publish: true
          disable-auto-evidence-collection: false
          oidc-audience: ${{ vars.JFROG_URL }}

      - name: "[Setup] Verify JFrog Authentication"
        run: |
          echo "üîê Verifying JFrog CLI authentication and connectivity..."
          jf rt ping
          echo "‚úÖ JFrog authentication successful"

      - name: "[Auth] Exchange OIDC and persist JF access token"
        id: exchange-oidc
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          PROJECT: ${{ vars.PROJECT_KEY }}
          PROVIDER_NAME: bookverse-web-github
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
          if [[ -z "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" || -z "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" ]]; then
            echo "‚ùå Missing GitHub OIDC request env vars" >&2; exit 1; fi
          GH_ID_TOKEN=$(curl -sS -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" \
            "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${JF_URL}" | jq -r .value)
          if [[ -z "$GH_ID_TOKEN" || "$GH_ID_TOKEN" == "null" ]]; then echo "‚ùå Failed to fetch GitHub ID token" >&2; exit 1; fi
          PAYLOAD=$(jq -n --arg jwt "$GH_ID_TOKEN" \
            --arg provider_name "$PROVIDER_NAME" \
            --arg project_key "$PROJECT" \
            --arg job_id "${{ github.job }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg repo "https://github.com/${{ github.repository }}" \
            --arg revision "${{ github.sha }}" \
            --arg branch "${{ github.ref_name }}" \
            '{
              grant_type:"urn:ietf:params:oauth:grant-type:token-exchange",
              subject_token_type:"urn:ietf:params:oauth:token-type:id_token",
              subject_token:$jwt,
              provider_name:$provider_name,
              project_key:$project_key,
              job_id:$job_id,
              run_id:$run_id,
              repo:$repo,
              revision:$revision,
              branch:$branch
            }')
          TOKEN=$(curl -sS -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "$JF_URL/access/api/v1/oidc/token" | jq -r .access_token)
          if [[ -z "$TOKEN" || "$TOKEN" == "null" ]]; then echo "‚ùå Failed to exchange OIDC token" >&2; exit 1; fi
          echo "JF_ACCESS_TOKEN=$TOKEN" >> $GITHUB_ENV

      - name: "[Setup] AppTrust variables"
        run: |
          SERVICE_NAME=$(echo ${{ github.event.repository.name }} | sed 's/bookverse-//')
          APP_VERSION=${{ needs.build-test-publish.outputs.app_version }}
          IMAGE_TAG="${APP_VERSION}"
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          BUILD_INFO_REPO="${{ vars.PROJECT_KEY }}-build-info"
          # Align with recommendations: recompute canonical build reference
          BUILD_NAME="${{ github.event.repository.name }}_${{ github.workflow }}_build-test-publish"
          BUILD_NUMBER="${{ github.run_number }}-${{ github.run_attempt }}"

          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
          echo "APPLICATION_KEY=$APPLICATION_KEY" >> $GITHUB_ENV
          echo "BUILD_INFO_REPO=$BUILD_INFO_REPO" >> $GITHUB_ENV
          echo "BUILD_NAME=$BUILD_NAME" >> $GITHUB_ENV
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV

          echo "‚úÖ AppTrust variables set:"
          echo "   üì¶ Application: $APPLICATION_KEY"
          echo "   üè∑Ô∏è Version: $APP_VERSION"
          echo "   üî® Build: $SERVICE_NAME#$IMAGE_TAG"

      - name: "[Diag] Build Info contents"
        run: |
          set -euo pipefail
          echo "üîé Fetching build info to confirm artifacts are present"
          ENC_BUILD_NAME=$(printf '%s' "$BUILD_NAME" | jq -sRr @uri)
          ENC_BUILD_NUMBER=$(printf '%s' "$BUILD_NUMBER" | jq -sRr @uri)
          URL="${{ vars.JFROG_URL }}/artifactory/api/build/${ENC_BUILD_NAME}/${ENC_BUILD_NUMBER}?project=${{ vars.PROJECT_KEY }}"
          echo "GET $URL"
          curl -sS -H "Authorization: Bearer $JF_ACCESS_TOKEN" -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" -H "Accept: application/json" "$URL" \
            | jq '.buildInfo.modules // [] | map({id, artifacts: (.artifacts // [] | length)})'

      - name: "[Release] Create application version"
        run: |
          echo "üöÄ Creating AppTrust application version: $APP_VERSION"

          # Determine application version tag - simulate real development environment
          # Array of realistic single tags for demo
          TAG_OPTIONS=(
            "release"
            "hotfix"
            "feature"
            "bugfix"
            "enhancement"
            "security"
            "performance"
            "refactor"
            "experimental"
            "maintenance"
            "integration"
            "documentation"
            "stable"
            "beta"
            "alpha"
            "critical"
            "patch"
            "minor"
            "major"
            "cleanup"
          )

          # Randomly select single tag based on run number for consistency
          TAG_INDEX=$((${GITHUB_RUN_NUMBER:-0} % ${#TAG_OPTIONS[@]}))
          APP_TAG="${TAG_OPTIONS[$TAG_INDEX]}"
          echo "üè∑Ô∏è Application Version Tag (demo simulation): $APP_TAG"

          # Create application version with build sources
          APP_VERSION_PAYLOAD=$(cat << EOF
          {
            "version": "$APP_VERSION",
            "tag": "$APP_TAG",
            "sources": {
              "builds": [
                {
                  "name": "$BUILD_NAME",
                  "number": "$BUILD_NUMBER",
                  "repository_key": "$BUILD_INFO_REPO",
                  "include_dependencies": false
                }
              ]
            }
          }
          EOF
          )

          # Debug: show sanitized curl and payload
          echo "üì¶ Application Key: $APPLICATION_KEY"
          echo "üìù Payload:"; echo "$APP_VERSION_PAYLOAD" | jq . || echo "$APP_VERSION_PAYLOAD"
          echo "üîó Curl (sanitized): curl -X POST '${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions?async=false' -H 'Authorization: Bearer ***' -H 'Content-Type: application/json' -H 'Accept: application/json' -d '<payload>'"

          # Ensure jq is present
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq >/dev/null; fi

          # Preflight: ensure the application exists; create if 404
          echo "üîç Preflight: ensuring application '$APPLICATION_KEY' exists"
          if ! jf curl -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" -H "Accept: application/json" "/apptrust/api/v1/applications/$APPLICATION_KEY" >/dev/null 2>&1; then
            echo "üÜï Application not found; creating it"
            CREATE_APP_BODY=$(jq -n --arg name "BookVerse Web" --arg key "$APPLICATION_KEY" --arg proj "${{ vars.PROJECT_KEY }}" '{application_name:$name, application_key:$key, project_key:$proj}')
            jf curl -X POST -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" -H "Content-Type: application/json" -H "Accept: application/json" -d "$CREATE_APP_BODY" "/apptrust/api/v1/applications/" >/tmp/app_create.json 2>/tmp/app_create.err || true
            echo "üì® Create Application Response:"; cat /tmp/app_create.json || true
          fi

          # Create application version via AppTrust API using admin token (align with recommendations)
          RESP_BODY=$(mktemp)
          HTTP_STATUS=$(curl -sS -L -o "$RESP_BODY" -w "%{http_code}" -X POST \
            "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions?async=false" \
            -H "Authorization: Bearer $JF_ACCESS_TOKEN" \
            -H "Content-Type: application/json" \
            -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" \
            -d "$APP_VERSION_PAYLOAD")
          echo "üî¢ HTTP Status: $HTTP_STATUS"
          echo "üì® Response Body:"; cat "$RESP_BODY" || true; echo
          rm -f "$RESP_BODY"
          if [[ "$HTTP_STATUS" -lt 200 || "$HTTP_STATUS" -ge 300 ]]; then
            echo "‚ùå Failed to create application version" >&2
            exit 1
          fi

          # Robust validation: fetch content and require status == COMPLETED
          CONTENT_FILE=$(mktemp)
          CONTENT_STATUS=$(curl -sS -L -o "$CONTENT_FILE" -w "%{http_code}" \
            "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions/$APP_VERSION/content" \
            -H "Authorization: Bearer $JF_ACCESS_TOKEN" \
            -H "Accept: application/json")
          if [[ "$CONTENT_STATUS" != "200" ]]; then
            echo "‚ùå Version content endpoint returned HTTP $CONTENT_STATUS for $APPLICATION_KEY@$APP_VERSION" >&2
            echo "üì® Response Body:"; cat "$CONTENT_FILE" || true; echo
            rm -f "$CONTENT_FILE"
            exit 1
          fi
          VERSION_STATE=$(jq -r '.status // empty' "$CONTENT_FILE" 2>/dev/null || echo "")
          echo "üì® Version Content:"; cat "$CONTENT_FILE" || true; echo
          rm -f "$CONTENT_FILE"
          if [[ "$VERSION_STATE" != "COMPLETED" ]]; then
            echo "‚ùå Application version not in COMPLETED state (status='$VERSION_STATE') for $APPLICATION_KEY@$APP_VERSION" >&2
            exit 1
          fi
          echo "‚úÖ Application version created and validated (COMPLETED): $APPLICATION_KEY@$APP_VERSION"
          echo "üì¶ Packages will be automatically bound from build sources"

      # Evidence Plan: App UNASSIGNED ‚Äì slsa-provenance and jira-tickets (gate to DEV)
      - name: "[Evidence] Prepare UNASSIGNED templates"
        run: |
          set -euo pipefail
          echo "üìÑ Preparing SLSA and Jira templates"
          cat > slsa.template.md <<'EOF'
          # SLSA Provenance Report üõ°Ô∏è

          This document summarizes the SLSA (Supply-chain Levels for Software Artifacts) provenance and build context for this version.

          ---

          ## Evidence Details

          * **Framework**: `SLSA`
          * **SLSA Level**: `v1`
          * **Generated At**: `${NOW_TS}`
          * **Builder**: `GitHub Actions`
          * **Workflow**: `${{ github.workflow }}`
          * **Repository**: `${{ github.repository }}`
          * **Commit**: `${{ github.sha }}`
          EOF
          cat > jira.template.md <<'EOF'
          # üé´ Jira Release Notes

          This evidence lists the Jira issues included in this application version.

          ---

          ## Tickets
          - ${T1} ‚Äî ${T1_TYPE}
          - ${T2} ‚Äî ${T2_TYPE}
          - ${T3} ‚Äî ${T3_TYPE}
          EOF

      - name: "[Evidence] Attach UNASSIGNED (SLSA, Jira)"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          if ! command -v envsubst >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y gettext-base; fi
          NOW_TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          export NOW_TS="${NOW_TS}"
          # SLSA predicate and markdown
          cat > slsa.json <<JSON
          {
            "provenance": {
              "framework": "SLSA",
              "level": "v1",
              "generatedAt": "${NOW_TS}",
              "attachStage": "UNASSIGNED",
              "gateForPromotionTo": "DEV"
            }
          }
          JSON
          envsubst < slsa.template.md > slsa.md
          jf evd create-evidence \
            --predicate slsa.json \
            --markdown slsa.md \
            --predicate-type "https://slsa.dev/provenance/v1" \
            --release-bundle "$APPLICATION_KEY" \
            --release-bundle-version "$APP_VERSION" \
            --project "${{ vars.PROJECT_KEY }}" \
            --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" \
            --key-alias "${{ vars.EVIDENCE_KEY_ALIAS }}"

          # Jira predicate and markdown
          # Generate a small set of pseudo tickets and types for the release notes
          T1="BV-$(( (${GITHUB_RUN_NUMBER:-0} % 200) + 100 ))"
          T2="BV-$(( ((${GITHUB_RUN_NUMBER:-0} + ${GITHUB_RUN_ATTEMPT:-0}) % 200) + 300 ))"
          T3="BV-$(( ((${GITHUB_RUN_NUMBER:-0} * 3 + ${GITHUB_RUN_ATTEMPT:-0}) % 200) + 500 ))"
          TYPES=(feature bug improvement)
          T1_TYPE="${TYPES[$(( ${GITHUB_RUN_NUMBER:-0} % 3 ))]}"
          T2_TYPE="${TYPES[$(( (${GITHUB_RUN_NUMBER:-0} + 1) % 3 ))]}"
          T3_TYPE="${TYPES[$(( (${GITHUB_RUN_NUMBER:-0} + 2) % 3 ))]}"
          export T1 T2 T3 T1_TYPE T2_TYPE T3_TYPE
          cat > jira.json <<JSON
          {
            "jira": {
              "tickets": [
                {"id": "${T1}", "type": "${T1_TYPE}"},
                {"id": "${T2}", "type": "${T2_TYPE}"},
                {"id": "${T3}", "type": "${T3_TYPE}"}
              ]
            }
          }
          JSON
          envsubst < jira.template.md > jira.md
          jf evd create-evidence \
            --predicate jira.json \
            --markdown jira.md \
            --predicate-type "https://atlassian.com/evidence/jira/release/v1" \
            --release-bundle "$APPLICATION_KEY" \
            --release-bundle-version "$APP_VERSION" \
            --project "${{ vars.PROJECT_KEY }}" \
            --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" \
            --key-alias "${{ vars.EVIDENCE_KEY_ALIAS }}"

      - name: "[Evidence] Attach SDLC"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          NOW_TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          cat > sdlc-evidence.json <<JSON
          {
            "sdlc": {
              "version": "$APP_VERSION",
              "releaseDate": "${NOW_TS}",
              "actor": "${{ github.actor }}",
              "build": {"name": "$BUILD_NAME", "number": "$BUILD_NUMBER"},
              "qualityGates": {"unitTests": "passed", "lint": "passed", "securityScan": "passed"}
            }
          }
          JSON
          cat > sdlc-evidence.md <<EOF
          # SDLC Release Evidence

          **Application Version:** $APP_VERSION  
          **Build:** $BUILD_NAME#$BUILD_NUMBER  

          ## ‚úÖ Quality Gates
          - Lint: Passed
          - Unit Tests: Passed
          - Security Scan: Passed
          EOF
          jf evd create-evidence \
            --predicate sdlc-evidence.json \
            --markdown sdlc-evidence.md \
            --predicate-type "SDLC Release" \
            --release-bundle "$APPLICATION_KEY" \
            --release-bundle-version "$APP_VERSION" \
            --project "${{ vars.PROJECT_KEY }}" \
            --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" || echo "‚ö†Ô∏è SDLC evidence attachment failed"

      - name: "[Summary] AppTrust"
        run: |
          echo "## üöÄ AppTrust Promotion Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Application:** \`$APPLICATION_KEY\`" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** \`$APP_VERSION\`" >> $GITHUB_STEP_SUMMARY
          echo "**Build:** \`$BUILD_NAME#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì¶ Artifacts Bound" >> $GITHUB_STEP_SUMMARY
          echo "- üê≥ Docker image: \`$SERVICE_NAME:$IMAGE_TAG\`" >> $GITHUB_STEP_SUMMARY
          echo "- üì¶ Web assets tar: \`$GENERIC_REPO/$SERVICE_NAME/assets/$IMAGE_TAG/web-assets-$IMAGE_TAG.tar.gz\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üõ°Ô∏è Evidence Added" >> $GITHUB_STEP_SUMMARY
          echo "- Code Quality (build)" >> $GITHUB_STEP_SUMMARY
          echo "- License Compliance (build)" >> $GITHUB_STEP_SUMMARY
          echo "- SLSA Provenance (release bundle)" >> $GITHUB_STEP_SUMMARY
          echo "- Jira Release Notes (release bundle)" >> $GITHUB_STEP_SUMMARY
          echo "- SDLC (release bundle)" >> $GITHUB_STEP_SUMMARY

